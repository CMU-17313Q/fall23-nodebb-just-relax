<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - test/messaging.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>test/messaging.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">69.45</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">868</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">82.44</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">14.38</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

const assert = require(&#039;assert&#039;);
const async = require(&#039;async&#039;);
const request = require(&#039;request-promise-native&#039;);
const nconf = require(&#039;nconf&#039;);
const util = require(&#039;util&#039;);

const sleep = util.promisify(setTimeout);

const db = require(&#039;./mocks/databasemock&#039;);
const meta = require(&#039;../src/meta&#039;);
const User = require(&#039;../src/user&#039;);
const Groups = require(&#039;../src/groups&#039;);
const Messaging = require(&#039;../src/messaging&#039;);
const helpers = require(&#039;./helpers&#039;);
const socketModules = require(&#039;../src/socket.io/modules&#039;);
const utils = require(&#039;../src/utils&#039;);
const translator = require(&#039;../src/translator&#039;);

describe(&#039;Messaging Library&#039;, () =&gt; {
    const mocks = {
        users: {
            foo: {}, // the admin
            bar: {},
            baz: {}, // the user with chat restriction enabled
            herp: {},
        },
    };
    let roomId;

    let chatMessageDelay;

    const callv3API = async (method, path, body, user) =&gt; {
        const options = {
            method,
            body,
            json: true,
            jar: mocks.users[user].jar,
            resolveWithFullResponse: true,
            simple: false,
        };

        if (method !== &#039;get&#039;) {
            options.headers = {
                &#039;x-csrf-token&#039;: mocks.users[user].csrf,
            };
        }

        return request(`${nconf.get(&#039;url&#039;)}/api/v3${path}`, options);
    };

    before(async () =&gt; {
        // Create 3 users: 1 admin, 2 regular
        ({
            foo: mocks.users.foo.uid,
            bar: mocks.users.bar.uid,
            baz: mocks.users.baz.uid,
            herp: mocks.users.herp.uid,
        } = await utils.promiseParallel({
            foo: User.create({ username: &#039;foo&#039;, password: &#039;barbar&#039; }), // admin
            bar: User.create({ username: &#039;bar&#039;, password: &#039;bazbaz&#039; }), // admin
            baz: User.create({ username: &#039;baz&#039;, password: &#039;quuxquux&#039; }), // restricted user
            herp: User.create({ username: &#039;herp&#039;, password: &#039;derpderp&#039; }), // a regular user
        }));

        await Groups.join(&#039;administrators&#039;, mocks.users.foo.uid);
        await User.setSetting(mocks.users.baz.uid, &#039;restrictChat&#039;, &#039;1&#039;);

        ({ jar: mocks.users.foo.jar, csrf_token: mocks.users.foo.csrf } = await util.promisify(helpers.loginUser)(&#039;foo&#039;, &#039;barbar&#039;));
        ({ jar: mocks.users.bar.jar, csrf_token: mocks.users.bar.csrf } = await util.promisify(helpers.loginUser)(&#039;bar&#039;, &#039;bazbaz&#039;));
        ({ jar: mocks.users.baz.jar, csrf_token: mocks.users.baz.csrf } = await util.promisify(helpers.loginUser)(&#039;baz&#039;, &#039;quuxquux&#039;));
        ({ jar: mocks.users.herp.jar, csrf_token: mocks.users.herp.csrf } = await util.promisify(helpers.loginUser)(&#039;herp&#039;, &#039;derpderp&#039;));

        chatMessageDelay = meta.config.chatMessageDelay;
        meta.config.chatMessageDelay = 0;
    });

    after(() =&gt; {
        meta.configs.chatMessageDelay = chatMessageDelay;
    });

    describe(&#039;.canMessage()&#039;, () =&gt; {
        it(&#039;should allow messages to be sent to an unrestricted user&#039;, (done) =&gt; {
            Messaging.canMessageUser(mocks.users.baz.uid, mocks.users.herp.uid, (err) =&gt; {
                assert.ifError(err);
                done();
            });
        });

        it(&#039;should NOT allow messages to be sent to a restricted user&#039;, async () =&gt; {
            await User.setSetting(mocks.users.baz.uid, &#039;restrictChat&#039;, &#039;1&#039;);
            try {
                await Messaging.canMessageUser(mocks.users.herp.uid, mocks.users.baz.uid);
            } catch (err) {
                assert.strictEqual(err.message, &#039;[[error:chat-restricted]]&#039;);
            }
        });

        it(&#039;should always allow admins through&#039;, (done) =&gt; {
            Messaging.canMessageUser(mocks.users.foo.uid, mocks.users.baz.uid, (err) =&gt; {
                assert.ifError(err);
                done();
            });
        });

        it(&#039;should allow messages to be sent to a restricted user if restricted user follows sender&#039;, (done) =&gt; {
            User.follow(mocks.users.baz.uid, mocks.users.herp.uid, () =&gt; {
                Messaging.canMessageUser(mocks.users.herp.uid, mocks.users.baz.uid, (err) =&gt; {
                    assert.ifError(err);
                    done();
                });
            });
        });
    });

    describe(&#039;rooms&#039;, () =&gt; {
        it(&#039;should fail to create a new chat room with invalid data&#039;, async () =&gt; {
            const { body } = await callv3API(&#039;post&#039;, &#039;/chats&#039;, {}, &#039;foo&#039;);
            assert.equal(body.status.message, await translator.translate(&#039;[[error:required-parameters-missing, uids]]&#039;));
        });

        it(&#039;should return rate limit error on second try&#039;, async () =&gt; {
            const oldValue = meta.config.chatMessageDelay;
            meta.config.chatMessageDelay = 1000;

            await callv3API(&#039;post&#039;, &#039;/chats&#039;, {
                uids: [mocks.users.baz.uid],
            }, &#039;foo&#039;);

            const { statusCode, body } = await callv3API(&#039;post&#039;, `/chats`, {
                uids: [mocks.users.baz.uid],
            }, &#039;foo&#039;);

            assert.equal(statusCode, 400);
            assert.equal(body.status.code, &#039;bad-request&#039;);
            assert.equal(body.status.message, await translator.translate(&#039;[[error:too-many-messages]]&#039;));
            meta.config.chatMessageDelay = oldValue;
        });

        it(&#039;should create a new chat room&#039;, async () =&gt; {
            await User.setSetting(mocks.users.baz.uid, &#039;restrictChat&#039;, &#039;0&#039;);
            const { body } = await callv3API(&#039;post&#039;, `/chats`, {
                uids: [mocks.users.baz.uid],
            }, &#039;foo&#039;);
            await User.setSetting(mocks.users.baz.uid, &#039;restrictChat&#039;, &#039;1&#039;);

            roomId = body.response.roomId;
            assert(roomId);

            await util.promisify(socketModules.chats.canMessage)({ uid: mocks.users.foo.uid }, roomId);
        });

        it(&#039;should send a user-join system message when a chat room is created&#039;, async () =&gt; {
            const { body } = await callv3API(&#039;get&#039;, `/chats/${roomId}`, {}, &#039;foo&#039;);
            const { messages } = body.response;
            assert.equal(messages.length, 2);
            assert.strictEqual(messages[0].system, true);
            assert.strictEqual(messages[0].content, &#039;user-join&#039;);

            const { statusCode, body: body2 } = await callv3API(&#039;put&#039;, `/chats/${roomId}/messages/${messages[0].messageId}`, {
                message: &#039;test&#039;,
            }, &#039;foo&#039;);
            assert.strictEqual(statusCode, 400);
            assert.equal(body2.status.message, await translator.translate(&#039;[[error:cant-edit-chat-message]]&#039;));
        });

        it(&#039;should fail to add user to room with invalid data&#039;, async () =&gt; {
            let { statusCode, body } = await callv3API(&#039;post&#039;, `/chats/${roomId}/users`, {}, &#039;foo&#039;);
            assert.strictEqual(statusCode, 400);
            assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:required-parameters-missing, uids]]&#039;));

            ({ statusCode, body } = await callv3API(&#039;post&#039;, `/chats/${roomId}/users`, { uids: [null] }, &#039;foo&#039;));
            assert.strictEqual(statusCode, 400);
            assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:no-user]]&#039;));
        });

        it(&#039;should add a user to room&#039;, async () =&gt; {
            await callv3API(&#039;post&#039;, `/chats/${roomId}/users`, { uids: [mocks.users.herp.uid] }, &#039;foo&#039;);
            const isInRoom = await Messaging.isUserInRoom(mocks.users.herp.uid, roomId);
            assert(isInRoom);
        });

        it(&#039;should get users in room&#039;, async () =&gt; {
            const { body } = await callv3API(&#039;get&#039;, `/chats/${roomId}/users`, {}, &#039;foo&#039;);
            assert(Array.isArray(body.response.users));
            assert.strictEqual(body.response.users.length, 3);
        });

        it(&#039;should throw error if user is not in room&#039;, async () =&gt; {
            const { statusCode, body } = await callv3API(&#039;get&#039;, `/chats/${roomId}/users`, {}, &#039;bar&#039;);
            assert.strictEqual(statusCode, 403);
            assert.equal(body.status.message, await translator.translate(&#039;[[error:no-privileges]]&#039;));
        });

        it(&#039;should fail to add users to room if max is reached&#039;, async () =&gt; {
            meta.config.maximumUsersInChatRoom = 2;
            const { statusCode, body } = await callv3API(&#039;post&#039;, `/chats/${roomId}/users`, { uids: [mocks.users.bar.uid] }, &#039;foo&#039;);
            assert.strictEqual(statusCode, 400);
            assert.equal(body.status.message, await translator.translate(&#039;[[error:cant-add-more-users-to-chat-room]]&#039;));
            meta.config.maximumUsersInChatRoom = 0;
        });

        it(&#039;should fail to add users to room if user does not exist&#039;, async () =&gt; {
            const { statusCode, body } = await callv3API(&#039;post&#039;, `/chats/${roomId}/users`, { uids: [98237498234] }, &#039;foo&#039;);
            assert.strictEqual(statusCode, 400);
            assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:no-user]]&#039;));
        });

        it(&#039;should fail to add self to room&#039;, async () =&gt; {
            const { statusCode, body } = await callv3API(&#039;post&#039;, `/chats/${roomId}/users`, { uids: [mocks.users.foo.uid] }, &#039;foo&#039;);
            assert.strictEqual(statusCode, 400);
            assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:cant-chat-with-yourself]]&#039;));
        });

        it(&#039;should fail to leave room with invalid data&#039;, async () =&gt; {
            let { statusCode, body } = await callv3API(&#039;delete&#039;, `/chats/${roomId}/users`, {}, &#039;foo&#039;);
            assert.strictEqual(statusCode, 400);
            assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:required-parameters-missing, uids]]&#039;));

            ({ statusCode, body } = await callv3API(&#039;delete&#039;, `/chats/${roomId}/users`, { uids: [98237423] }, &#039;foo&#039;));
            assert.strictEqual(statusCode, 400);
            assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:no-user]]&#039;));
        });

        it(&#039;should leave the chat room&#039;, async () =&gt; {
            await callv3API(&#039;delete&#039;, `/chats/${roomId}/users/${mocks.users.baz.uid}`, {}, &#039;baz&#039;);
            const isUserInRoom = await Messaging.isUserInRoom(mocks.users.baz.uid, roomId);
            assert.equal(isUserInRoom, false);
            const data = await Messaging.getRoomData(roomId);
            assert.equal(data.owner, mocks.users.foo.uid);
        });

        it(&#039;should send a user-leave system message when a user leaves the chat room&#039;, (done) =&gt; {
            socketModules.chats.getMessages(
                { uid: mocks.users.foo.uid },
                { uid: mocks.users.foo.uid, roomId: roomId, start: 0 },
                (err, messages) =&gt; {
                    assert.ifError(err);
                    assert.equal(messages.length, 4);
                    const message = messages.pop();
                    assert.strictEqual(message.system, true);
                    assert.strictEqual(message.content, &#039;user-leave&#039;);
                    done();
                }
            );
        });

        it(&#039;should not send a user-leave system message when a user tries to leave a room they are not in&#039;, async () =&gt; {
            await callv3API(&#039;delete&#039;, `/chats/${roomId}/users/${mocks.users.baz.uid}`, {}, &#039;baz&#039;);
            const messages = await socketModules.chats.getMessages(
                { uid: mocks.users.foo.uid },
                { uid: mocks.users.foo.uid, roomId: roomId, start: 0 }
            );
            assert.equal(messages.length, 4);
            let message = messages.pop();
            assert.strictEqual(message.system, true);
            assert.strictEqual(message.content, &#039;user-leave&#039;);

            // The message before should still be a user-join
            message = messages.pop();
            assert.strictEqual(message.system, true);
            assert.strictEqual(message.content, &#039;user-join&#039;);
        });

        it(&#039;should change owner when owner leaves room&#039;, async () =&gt; {
            const { body } = await callv3API(&#039;post&#039;, &#039;/chats&#039;, {
                uids: [mocks.users.foo.uid],
            }, &#039;herp&#039;);

            await callv3API(&#039;post&#039;, `/chats/${body.response.roomId}/users`, { uids: [mocks.users.baz.uid] }, &#039;herp&#039;);
            await util.promisify(socketModules.chats.leave)({ uid: mocks.users.herp.uid }, body.response.roomId);

            const data = await Messaging.getRoomData(body.response.roomId);
            assert.equal(data.owner, mocks.users.foo.uid);
        });

        it(&#039;should change owner if owner is deleted&#039;, async () =&gt; {
            const sender = await User.create({ username: &#039;deleted_chat_user&#039;, password: &#039;barbar&#039; });
            const { jar: senderJar, csrf_token: senderCsrf } = await util.promisify(helpers.loginUser)(&#039;deleted_chat_user&#039;, &#039;barbar&#039;);

            const receiver = await User.create({ username: &#039;receiver&#039; });
            const { response } = await request(`${nconf.get(&#039;url&#039;)}/api/v3/chats`, {
                method: &#039;post&#039;,
                json: true,
                jar: senderJar,
                body: {
                    uids: [receiver],
                },
                headers: {
                    &#039;x-csrf-token&#039;: senderCsrf,
                },
            });
            await User.deleteAccount(sender);
            const data = await Messaging.getRoomData(response.roomId);
            assert.equal(data.owner, receiver);
        });

        it(&#039;should fail to remove user from room&#039;, async () =&gt; {
            let { statusCode, body } = await callv3API(&#039;delete&#039;, `/chats/${roomId}/users`, {}, &#039;foo&#039;);
            assert.strictEqual(statusCode, 400);
            assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:required-parameters-missing, uids]]&#039;));

            ({ statusCode, body } = await callv3API(&#039;delete&#039;, `/chats/${roomId}/users`, { uids: [null] }, &#039;foo&#039;));
            assert.strictEqual(statusCode, 400);
            assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:no-user]]&#039;));
        });

        it(&#039;should fail to remove user from room if user does not exist&#039;, async () =&gt; {
            const { statusCode, body } = await callv3API(&#039;delete&#039;, `/chats/${roomId}/users`, { uids: [99] }, &#039;foo&#039;);
            assert.strictEqual(statusCode, 400);
            assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:no-user]]&#039;));
        });

        it(&#039;should remove user from room&#039;, async () =&gt; {
            const { statusCode, body } = await callv3API(&#039;post&#039;, `/chats`, {
                uids: [mocks.users.herp.uid],
            }, &#039;foo&#039;);
            const { roomId } = body.response;
            assert.strictEqual(statusCode, 200);

            let isInRoom = await Messaging.isUserInRoom(mocks.users.herp.uid, roomId);
            assert(isInRoom);

            await callv3API(&#039;delete&#039;, `/chats/${roomId}/users`, { uids: [mocks.users.herp.uid] }, &#039;foo&#039;);
            isInRoom = await Messaging.isUserInRoom(mocks.users.herp.uid, roomId);
            assert(!isInRoom);
        });

        it(&#039;should fail to send a message to room with invalid data&#039;, async () =&gt; {
            let { body } = await callv3API(&#039;post&#039;, `/chats/abc`, { message: &#039;test&#039; }, &#039;foo&#039;);
            assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:invalid-data]]&#039;));

            ({ body } = await callv3API(&#039;post&#039;, `/chats/1`, {}, &#039;foo&#039;));
            assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:required-parameters-missing, message]]&#039;));
        });

        it(&#039;should fail to send chat if content is empty&#039;, async () =&gt; {
            const { body } = await callv3API(&#039;post&#039;, `/chats/${roomId}`, {
                message: &#039; &#039;,
            }, &#039;foo&#039;);
            const { status, response } = body;

            assert.deepStrictEqual(response, {});
            assert.equal(status.message, await translator.translate(&#039;[[error:invalid-chat-message]]&#039;));
        });

        it(&#039;should send a message to a room&#039;, async () =&gt; {
            const socketMock = { uid: mocks.users.foo.uid };
            const { body } = await callv3API(&#039;post&#039;, `/chats/${roomId}`, { roomId: roomId, message: &#039;first chat message&#039; }, &#039;foo&#039;);
            const messageData = body.response;
            assert(messageData);
            assert.equal(messageData.content, &#039;first chat message&#039;);
            assert(messageData.fromUser);
            assert(messageData.roomId, roomId);
            const raw =
                await util.promisify(socketModules.chats.getRaw)(socketMock, { mid: messageData.mid });
            assert.equal(raw, &#039;first chat message&#039;);
        });

        it(&#039;should fail to send second message due to rate limit&#039;, async () =&gt; {
            const socketMock = { uid: mocks.users.foo.uid };
            const oldValue = meta.config.chatMessageDelay;
            meta.config.chatMessageDelay = 1000;

            await callv3API(&#039;post&#039;, `/chats/${roomId}`, { roomId: roomId, message: &#039;first chat message&#039; }, &#039;foo&#039;);
            const { body } = await callv3API(&#039;post&#039;, `/chats/${roomId}`, { roomId: roomId, message: &#039;first chat message&#039; }, &#039;foo&#039;);
            const { status } = body;
            assert.equal(status.message, await translator.translate(&#039;[[error:too-many-messages]]&#039;));
            meta.config.chatMessageDelay = oldValue;
        });

        it(&#039;should return invalid-data error&#039;, (done) =&gt; {
            socketModules.chats.getRaw({ uid: mocks.users.foo.uid }, null, (err) =&gt; {
                assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
                socketModules.chats.getRaw({ uid: mocks.users.foo.uid }, {}, (err) =&gt; {
                    assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
                    done();
                });
            });
        });

        it(&#039;should return not allowed error if mid is not in room&#039;, async () =&gt; {
            const socketMock = { uid: mocks.users.foo.uid };
            const uids = await User.create({ username: &#039;dummy&#039; });
            let { body } = await callv3API(&#039;post&#039;, &#039;/chats&#039;, { uids: [uids] }, &#039;baz&#039;);
            const myRoomId = body.response.roomId;
            assert(myRoomId);

            try {
                await util.promisify(socketModules.chats.getRaw)({ uid: mocks.users.baz.uid }, { mid: 200 });
            } catch (err) {
                assert(err);
                assert.equal(err.message, &#039;[[error:not-allowed]]&#039;);
            }

            ({ body } = await callv3API(&#039;post&#039;, `/chats/${myRoomId}`, { roomId: myRoomId, message: &#039;admin will see this&#039; }, &#039;baz&#039;));
            const message = body.response;
            const raw = await util.promisify(socketModules.chats.getRaw)(socketMock, { mid: message.mid });
            assert.equal(raw, &#039;admin will see this&#039;);
        });


        it(&#039;should notify offline users of message&#039;, async () =&gt; {
            meta.config.notificationSendDelay = 0.1;

            const { body } = await callv3API(&#039;post&#039;, &#039;/chats&#039;, { uids: [mocks.users.baz.uid] }, &#039;foo&#039;);
            const { roomId } = body.response;
            assert(roomId);

            await callv3API(&#039;post&#039;, `/chats/${roomId}/users`, { uids: [mocks.users.herp.uid] }, &#039;foo&#039;);
            await db.sortedSetAdd(&#039;users:online&#039;, Date.now() - ((meta.config.onlineCutoff * 60000) + 50000), mocks.users.herp.uid);

            await callv3API(&#039;post&#039;, `/chats/${roomId}`, { roomId: roomId, message: &#039;second chat message **bold** text&#039; }, &#039;foo&#039;);
            await sleep(3000);
            const data = await User.notifications.get(mocks.users.herp.uid);
            assert(data.unread[0]);
            const notification = data.unread[0];
            assert.strictEqual(notification.bodyShort, &#039;[[notifications:new_message_from, foo]]&#039;);
            assert.strictEqual(notification.nid, `chat_${mocks.users.foo.uid}_${roomId}`);
            assert.strictEqual(notification.path, `${nconf.get(&#039;relative_path&#039;)}/chats/${roomId}`);
        });

        it(&#039;should fail to get messages from room with invalid data&#039;, (done) =&gt; {
            const socketMock = { uid: mocks.users.foo.uid };
            socketModules.chats.getMessages({ uid: null }, null, (err) =&gt; {
                assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
                socketModules.chats.getMessages(socketMock, null, (err) =&gt; {
                    assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
                    socketModules.chats.getMessages(socketMock, { uid: null }, (err) =&gt; {
                        assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
                        socketModules.chats.getMessages(socketMock, { uid: 1, roomId: null }, (err) =&gt; {
                            assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
                            done();
                        });
                    });
                });
            });
        });

        it(&#039;should get messages from room&#039;, (done) =&gt; {
            socketModules.chats.getMessages({ uid: mocks.users.foo.uid }, {
                uid: mocks.users.foo.uid,
                roomId: roomId,
                start: 0,
            }, (err, messages) =&gt; {
                assert.ifError(err);
                assert(Array.isArray(messages));

                // Filter out system messages
                messages = messages.filter(message =&gt; !message.system);
                assert.equal(messages[0].roomId, roomId);
                assert.equal(messages[0].fromuid, mocks.users.foo.uid);
                done();
            });
        });

        it(&#039;should fail to mark read with invalid data&#039;, (done) =&gt; {
            socketModules.chats.markRead({ uid: null }, roomId, (err) =&gt; {
                assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
                socketModules.chats.markRead({ uid: mocks.users.foo.uid }, null, (err) =&gt; {
                    assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
                    done();
                });
            });
        });

        it(&#039;should not error if user is not in room&#039;, (done) =&gt; {
            socketModules.chats.markRead({ uid: mocks.users.herp.uid }, 10, (err) =&gt; {
                assert.ifError(err);
                done();
            });
        });

        it(&#039;should mark room read&#039;, (done) =&gt; {
            socketModules.chats.markRead({ uid: mocks.users.foo.uid }, roomId, (err) =&gt; {
                assert.ifError(err);
                done();
            });
        });

        it(&#039;should mark all rooms read&#039;, (done) =&gt; {
            socketModules.chats.markAllRead({ uid: mocks.users.foo.uid }, {}, (err) =&gt; {
                assert.ifError(err);
                done();
            });
        });

        it(&#039;should fail to rename room with invalid data&#039;, async () =&gt; {
            let { body } = await callv3API(&#039;put&#039;, `/chats/${roomId}`, { name: null }, &#039;foo&#039;);
            assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:invalid-data]]&#039;));

            ({ body } = await callv3API(&#039;put&#039;, `/chats/${roomId}`, {}, &#039;foo&#039;));
            assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:required-parameters-missing, name]]&#039;));
        });

        it(&#039;should rename room&#039;, async () =&gt; {
            const { statusCode } = await callv3API(&#039;put&#039;, `/chats/${roomId}`, { name: &#039;new room name&#039; }, &#039;foo&#039;);
            assert.strictEqual(statusCode, 200);
        });

        it(&#039;should send a room-rename system message when a room is renamed&#039;, (done) =&gt; {
            socketModules.chats.getMessages(
                { uid: mocks.users.foo.uid },
                { uid: mocks.users.foo.uid, roomId: roomId, start: 0 },
                (err, messages) =&gt; {
                    assert.ifError(err);
                    const message = messages.pop();
                    assert.strictEqual(message.system, true);
                    assert.strictEqual(message.content, &#039;room-rename, new room name&#039;);
                    done();
                }
            );
        });

        it(&#039;should fail to load room with invalid-data&#039;, async () =&gt; {
            const { body } = await callv3API(&#039;get&#039;, `/chats/abc`, {}, &#039;foo&#039;);
            assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:invalid-data]]&#039;));
        });

        it(&#039;should fail to load room if user is not in&#039;, async () =&gt; {
            const { body } = await callv3API(&#039;get&#039;, `/chats/${roomId}`, {}, &#039;baz&#039;);
            assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:no-privileges]]&#039;));
        });

        it(&#039;should load chat room&#039;, async () =&gt; {
            const { body } = await callv3API(&#039;get&#039;, `/chats/${roomId}`, {}, &#039;foo&#039;);
            assert.strictEqual(body.response.roomName, &#039;new room name&#039;);
        });

        it(&#039;should return true if user is dnd&#039;, (done) =&gt; {
            db.setObjectField(`user:${mocks.users.herp.uid}`, &#039;status&#039;, &#039;dnd&#039;, (err) =&gt; {
                assert.ifError(err);
                socketModules.chats.isDnD({ uid: mocks.users.foo.uid }, mocks.users.herp.uid, (err, isDnD) =&gt; {
                    assert.ifError(err);
                    assert(isDnD);
                    done();
                });
            });
        });

        it(&#039;should fail to load recent chats with invalid data&#039;, (done) =&gt; {
            socketModules.chats.getRecentChats({ uid: mocks.users.foo.uid }, null, (err) =&gt; {
                assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
                socketModules.chats.getRecentChats({ uid: mocks.users.foo.uid }, { after: null }, (err) =&gt; {
                    assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
                    socketModules.chats.getRecentChats({ uid: mocks.users.foo.uid }, { after: 0, uid: null }, (err) =&gt; {
                        assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
                        done();
                    });
                });
            });
        });

        it(&#039;should load recent chats of user&#039;, (done) =&gt; {
            socketModules.chats.getRecentChats(
                { uid: mocks.users.foo.uid },
                { after: 0, uid: mocks.users.foo.uid },
                (err, data) =&gt; {
                    assert.ifError(err);
                    assert(Array.isArray(data.rooms));
                    done();
                }
            );
        });

        it(&#039;should escape teaser&#039;, async () =&gt; {
            await callv3API(&#039;post&#039;, `/chats/${roomId}`, { roomId: roomId, message: &#039;&lt;svg/onload=alert(document.location);&#039; }, &#039;foo&#039;);
            const data = await util.promisify(socketModules.chats.getRecentChats)(
                { uid: mocks.users.foo.uid },
                { after: 0, uid: mocks.users.foo.uid }
            );

            assert.equal(data.rooms[0].teaser.content, &#039;&amp;lt;svg&amp;#x2F;onload=alert(document.location);&#039;);
        });

        it(&#039;should fail to check if user has private chat with invalid data&#039;, (done) =&gt; {
            socketModules.chats.hasPrivateChat({ uid: null }, null, (err) =&gt; {
                assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
                socketModules.chats.hasPrivateChat({ uid: mocks.users.foo.uid }, null, (err) =&gt; {
                    assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
                    done();
                });
            });
        });

        it(&#039;should check if user has private chat with another uid&#039;, (done) =&gt; {
            socketModules.chats.hasPrivateChat({ uid: mocks.users.foo.uid }, mocks.users.herp.uid, (err, roomId) =&gt; {
                assert.ifError(err);
                assert(roomId);
                done();
            });
        });
    });

    describe(&#039;edit/delete&#039;, () =&gt; {
        const socketModules = require(&#039;../src/socket.io/modules&#039;);
        let mid;
        let mid2;
        before(async () =&gt; {
            await callv3API(&#039;post&#039;, `/chats/${roomId}/users`, { uids: [mocks.users.baz.uid] }, &#039;foo&#039;);
            let { body } = await callv3API(&#039;post&#039;, `/chats/${roomId}`, { roomId: roomId, message: &#039;first chat message&#039; }, &#039;foo&#039;);
            mid = body.response.mid;
            ({ body } = await callv3API(&#039;post&#039;, `/chats/${roomId}`, { roomId: roomId, message: &#039;second chat message&#039; }, &#039;baz&#039;));
            mid2 = body.response.mid;
        });

        after(async () =&gt; {
            await callv3API(&#039;delete&#039;, `/chats/${roomId}/users/${mocks.users.baz.uid}`, {}, &#039;baz&#039;);
        });

        it(&#039;should fail to edit message with invalid data&#039;, async () =&gt; {
            let { statusCode, body } = await callv3API(&#039;put&#039;, `/chats/1/messages/10000`, { message: &#039;foo&#039; }, &#039;foo&#039;);
            assert.strictEqual(statusCode, 400);
            assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:invalid-mid]]&#039;));

            ({ statusCode, body } = await callv3API(&#039;put&#039;, `/chats/${roomId}/messages/${mid}`, {}, &#039;foo&#039;));
            assert.strictEqual(statusCode, 400);
            assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:invalid-chat-message]]&#039;));
        });

        it(&#039;should fail to edit message if new content is empty string&#039;, async () =&gt; {
            const { statusCode, body } = await callv3API(&#039;put&#039;, `/chats/${roomId}/messages/${mid}`, { message: &#039; &#039; }, &#039;foo&#039;);
            assert.strictEqual(statusCode, 400);
            assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:invalid-chat-message]]&#039;));
        });

        it(&#039;should fail to edit message if not own message&#039;, async () =&gt; {
            const { statusCode, body } = await callv3API(&#039;put&#039;, `/chats/${roomId}/messages/${mid}`, { message: &#039;message edited&#039; }, &#039;herp&#039;);
            assert.strictEqual(statusCode, 400);
            assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:cant-edit-chat-message]]&#039;));
        });

        it(&#039;should fail to edit message if message not in room&#039;, async () =&gt; {
            const { statusCode, body } = await callv3API(&#039;put&#039;, `/chats/${roomId}/messages/1014`, { message: &#039;message edited&#039; }, &#039;herp&#039;);
            assert.strictEqual(statusCode, 400);
            assert.strictEqual(body.status.message, await translator.translate(&#039;[[error:invalid-mid]]&#039;));
        });

        it(&#039;should edit message&#039;, async () =&gt; {
            let { statusCode, body } = await callv3API(&#039;put&#039;, `/chats/${roomId}/messages/${mid}`, { message: &#039;message edited&#039; }, &#039;foo&#039;);
            assert.strictEqual(statusCode, 200);
            assert.strictEqual(body.response.content, &#039;message edited&#039;);

            ({ statusCode, body } = await callv3API(&#039;get&#039;, `/chats/${roomId}/messages/${mid}`, {}, &#039;foo&#039;));
            assert.strictEqual(statusCode, 200);
            assert.strictEqual(body.response.content, &#039;message edited&#039;);
        });

        it(&#039;should fail to delete message with invalid data&#039;, (done) =&gt; {
            socketModules.chats.delete({ uid: mocks.users.foo.uid }, null, (err) =&gt; {
                assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
                socketModules.chats.delete({ uid: mocks.users.foo.uid }, { roomId: null }, (err) =&gt; {
                    assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
                    socketModules.chats.delete({ uid: mocks.users.foo.uid }, { roomId: 1, messageId: null }, (err) =&gt; {
                        assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
                        done();
                    });
                });
            });
        });

        it(&#039;should fail to delete message if not owner&#039;, (done) =&gt; {
            socketModules.chats.delete({ uid: mocks.users.herp.uid }, { messageId: mid, roomId: roomId }, (err) =&gt; {
                assert.equal(err.message, &#039;[[error:cant-delete-chat-message]]&#039;);
                done();
            });
        });

        it(&#039;should mark the message as deleted&#039;, (done) =&gt; {
            socketModules.chats.delete({ uid: mocks.users.foo.uid }, { messageId: mid, roomId: roomId }, (err) =&gt; {
                assert.ifError(err);
                db.getObjectField(`message:${mid}`, &#039;deleted&#039;, (err, value) =&gt; {
                    assert.ifError(err);
                    assert.strictEqual(1, parseInt(value, 10));
                    done();
                });
            });
        });

        it(&#039;should show deleted message to original users&#039;, (done) =&gt; {
            socketModules.chats.getMessages(
                { uid: mocks.users.foo.uid },
                { uid: mocks.users.foo.uid, roomId: roomId, start: 0 },
                (err, messages) =&gt; {
                    assert.ifError(err);

                    // Reduce messages to their mids
                    const mids = messages.reduce((mids, cur) =&gt; {
                        mids.push(cur.messageId);
                        return mids;
                    }, []);

                    assert(mids.includes(mid));
                    done();
                }
            );
        });

        it(&#039;should not show deleted message to other users&#039;, (done) =&gt; {
            socketModules.chats.getMessages(
                { uid: mocks.users.herp.uid },
                { uid: mocks.users.herp.uid, roomId: roomId, start: 0 },
                (err, messages) =&gt; {
                    assert.ifError(err);
                    messages.forEach((msg) =&gt; {
                        assert(!msg.deleted || msg.content === &#039;[[modules:chat.message-deleted]]&#039;, msg.content);
                        assert(!msg.deleted || msg.cleanedContent, &#039;[[modules:chat.message-deleted]]&#039;, msg.content);
                    });
                    done();
                }
            );
        });

        it(&#039;should error out if a message is deleted again&#039;, (done) =&gt; {
            socketModules.chats.delete({ uid: mocks.users.foo.uid }, { messageId: mid, roomId: roomId }, (err) =&gt; {
                assert.strictEqual(&#039;[[error:chat-deleted-already]]&#039;, err.message);
                done();
            });
        });

        it(&#039;should restore the message&#039;, (done) =&gt; {
            socketModules.chats.restore({ uid: mocks.users.foo.uid }, { messageId: mid, roomId: roomId }, (err) =&gt; {
                assert.ifError(err);
                db.getObjectField(`message:${mid}`, &#039;deleted&#039;, (err, value) =&gt; {
                    assert.ifError(err);
                    assert.strictEqual(0, parseInt(value, 10));
                    done();
                });
            });
        });

        it(&#039;should error out if a message is restored again&#039;, (done) =&gt; {
            socketModules.chats.restore({ uid: mocks.users.foo.uid }, { messageId: mid, roomId: roomId }, (err) =&gt; {
                assert.strictEqual(&#039;[[error:chat-restored-already]]&#039;, err.message);
                done();
            });
        });

        describe(&#039;disabled via ACP&#039;, () =&gt; {
            before(async () =&gt; {
                meta.config.disableChatMessageEditing = true;
            });

            after(async () =&gt; {
                meta.config.disableChatMessageEditing = false;
            });

            it(&#039;should error out for regular users&#039;, async () =&gt; {
                try {
                    await socketModules.chats.delete({ uid: mocks.users.baz.uid }, { messageId: mid2, roomId: roomId });
                } catch (err) {
                    assert.strictEqual(&#039;[[error:chat-message-editing-disabled]]&#039;, err.message);
                }
            });

            it(&#039;should succeed for administrators&#039;, async () =&gt; {
                await socketModules.chats.delete({ uid: mocks.users.foo.uid }, { messageId: mid2, roomId: roomId });
                await socketModules.chats.restore({ uid: mocks.users.foo.uid }, { messageId: mid2, roomId: roomId });
            });

            it(&#039;should succeed for global moderators&#039;, async () =&gt; {
                await Groups.join([&#039;Global Moderators&#039;], mocks.users.baz.uid);

                await socketModules.chats.delete({ uid: mocks.users.foo.uid }, { messageId: mid2, roomId: roomId });
                await socketModules.chats.restore({ uid: mocks.users.foo.uid }, { messageId: mid2, roomId: roomId });

                await Groups.leave([&#039;Global Moderators&#039;], mocks.users.baz.uid);
            });
        });
    });

    describe(&#039;controller&#039;, () =&gt; {
        it(&#039;should 404 if chat is disabled&#039;, async () =&gt; {
            meta.config.disableChat = 1;
            const response = await request(`${nconf.get(&#039;url&#039;)}/user/baz/chats`, {
                resolveWithFullResponse: true,
                simple: false,
            });

            assert.equal(response.statusCode, 404);
        });

        it(&#039;should 500 for guest with no privilege error&#039;, async () =&gt; {
            meta.config.disableChat = 0;
            const response = await request(`${nconf.get(&#039;url&#039;)}/api/user/baz/chats`, {
                resolveWithFullResponse: true,
                simple: false,
                json: true,
            });
            const { body } = response;

            assert.equal(response.statusCode, 500);
            assert.equal(body.error, &#039;[[error:no-privileges]]&#039;);
        });

        it(&#039;should 404 for non-existent user&#039;, async () =&gt; {
            const response = await request(`${nconf.get(&#039;url&#039;)}/user/doesntexist/chats`, {
                resolveWithFullResponse: true,
                simple: false,
            });

            assert.equal(response.statusCode, 404);
        });
    });

    describe(&#039;logged in chat controller&#039;, () =&gt; {
        let jar;
        before(async () =&gt; {
            ({ jar } = await helpers.loginUser(&#039;herp&#039;, &#039;derpderp&#039;));
        });

        it(&#039;should return chats page data&#039;, async () =&gt; {
            const response = await request(`${nconf.get(&#039;url&#039;)}/api/user/herp/chats`, {
                resolveWithFullResponse: true,
                simple: false,
                json: true,
                jar,
            });
            const { body } = response;

            assert.equal(response.statusCode, 200);
            assert(Array.isArray(body.rooms));
            assert.equal(body.rooms.length, 2);
            assert.equal(body.title, &#039;[[pages:chats]]&#039;);
        });

        it(&#039;should return room data&#039;, async () =&gt; {
            const response = await request(`${nconf.get(&#039;url&#039;)}/api/user/herp/chats/${roomId}`, {
                resolveWithFullResponse: true,
                simple: false,
                json: true,
                jar,
            });
            const { body } = response;

            assert.equal(response.statusCode, 200);
            assert.equal(body.roomId, roomId);
            assert.equal(body.isOwner, false);
        });

        it(&#039;should redirect to chats page&#039;, async () =&gt; {
            const res = await request(`${nconf.get(&#039;url&#039;)}/api/chats`, {
                resolveWithFullResponse: true,
                simple: false,
                jar,
                json: true,
            });
            const { body } = res;

            assert.equal(res.statusCode, 200);
            assert.equal(res.headers[&#039;x-redirect&#039;], &#039;/user/herp/chats&#039;);
            assert.equal(body, &#039;/user/herp/chats&#039;);
        });

        it(&#039;should return 404 if user is not in room&#039;, async () =&gt; {
            const data = await util.promisify(helpers.loginUser)(&#039;baz&#039;, &#039;quuxquux&#039;);
            const response = await request(`${nconf.get(&#039;url&#039;)}/api/user/baz/chats/${roomId}`, {
                resolveWithFullResponse: true,
                simple: false,
                json: true,
                jar: data.jar,
            });

            assert.equal(response.statusCode, 404);
        });
    });
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
