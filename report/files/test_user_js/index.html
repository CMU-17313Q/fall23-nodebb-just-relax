<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - test/user.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>test/user.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">72.83</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">3087</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">110.11</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">46.13</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

const assert = require(&#039;assert&#039;);
const async = require(&#039;async&#039;);
const fs = require(&#039;fs&#039;);
const path = require(&#039;path&#039;);
const nconf = require(&#039;nconf&#039;);
const validator = require(&#039;validator&#039;);
const request = require(&#039;request&#039;);
const requestAsync = require(&#039;request-promise-native&#039;);
const jwt = require(&#039;jsonwebtoken&#039;);

const db = require(&#039;./mocks/databasemock&#039;);
const User = require(&#039;../src/user&#039;);
const Topics = require(&#039;../src/topics&#039;);
const Categories = require(&#039;../src/categories&#039;);
const Posts = require(&#039;../src/posts&#039;);
const Password = require(&#039;../src/password&#039;);
const groups = require(&#039;../src/groups&#039;);
const messaging = require(&#039;../src/messaging&#039;);
const helpers = require(&#039;./helpers&#039;);
const meta = require(&#039;../src/meta&#039;);
const file = require(&#039;../src/file&#039;);
const socketUser = require(&#039;../src/socket.io/user&#039;);
const apiUser = require(&#039;../src/api/users&#039;);
const utils = require(&#039;../src/utils&#039;);
const privileges = require(&#039;../src/privileges&#039;);

describe(&#039;User&#039;, () =&gt; {
    let userData;
    let testUid;
    let testCid;

    const plugins = require(&#039;../src/plugins&#039;);

    async function dummyEmailerHook(data) {
        // pretend to handle sending emails
    }
    before((done) =&gt; {
        // Attach an emailer hook so related requests do not error
        plugins.hooks.register(&#039;emailer-test&#039;, {
            hook: &#039;filter:email.send&#039;,
            method: dummyEmailerHook,
        });

        Categories.create({
            name: &#039;Test Category&#039;,
            description: &#039;A test&#039;,
            order: 1,
        }, (err, categoryObj) =&gt; {
            if (err) {
                return done(err);
            }

            testCid = categoryObj.cid;
            done();
        });
    });
    after(() =&gt; {
        plugins.hooks.unregister(&#039;emailer-test&#039;, &#039;filter:email.send&#039;);
    });

    beforeEach(() =&gt; {
        userData = {
            username: &#039;John Smith&#039;,
            fullname: &#039;John Smith McNamara&#039;,
            password: &#039;swordfish&#039;,
            email: &#039;john@example.com&#039;,
            callback: undefined,
        };
    });

    const goodImage = &#039;data:image/png;base64,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&#039;;

    describe(&#039;.create(), when created&#039;, () =&gt; {
        it(&#039;should be created properly&#039;, async () =&gt; {
            testUid = await User.create({ username: userData.username, password: userData.password });
            assert.ok(testUid);

            await User.setUserField(testUid, &#039;email&#039;, userData.email);
            await User.email.confirmByUid(testUid);
        });

        it(&#039;should be created properly&#039;, async () =&gt; {
            const email = &#039;&lt;h1&gt;test&lt;/h1&gt;@gmail.com&#039;;
            const uid = await User.create({ username: &#039;weirdemail&#039;, email: email });
            const data = await User.getUserData(uid);

            const validationPending = await User.email.isValidationPending(uid, email);
            assert.strictEqual(validationPending, true);

            assert.equal(data.email, &#039;&amp;lt;h1&amp;gt;test&amp;lt;&amp;#x2F;h1&amp;gt;@gmail.com&#039;);
            assert.strictEqual(data.profileviews, 0);
            assert.strictEqual(data.reputation, 0);
            assert.strictEqual(data.postcount, 0);
            assert.strictEqual(data.topiccount, 0);
            assert.strictEqual(data.lastposttime, 0);
            assert.strictEqual(data.banned, false);
        });

        it(&#039;should have a valid email, if using an email&#039;, (done) =&gt; {
            User.create({ username: userData.username, password: userData.password, email: &#039;fakeMail&#039; }, (err) =&gt; {
                assert(err);
                assert.equal(err.message, &#039;[[error:invalid-email]]&#039;);
                done();
            });
        });

        it(&#039;should error with invalid password&#039;, (done) =&gt; {
            User.create({ username: &#039;test&#039;, password: &#039;1&#039; }, (err) =&gt; {
                assert.equal(err.message, &#039;[[reset_password:password_too_short]]&#039;);
                done();
            });
        });

        it(&#039;should error with invalid password&#039;, (done) =&gt; {
            User.create({ username: &#039;test&#039;, password: {} }, (err) =&gt; {
                assert.equal(err.message, &#039;[[error:invalid-password]]&#039;);
                done();
            });
        });

        it(&#039;should error with a too long password&#039;, (done) =&gt; {
            let toolong = &#039;&#039;;
            for (let i = 0; i &lt; 5000; i++) {
                toolong += &#039;a&#039;;
            }
            User.create({ username: &#039;test&#039;, password: toolong }, (err) =&gt; {
                assert.equal(err.message, &#039;[[error:password-too-long]]&#039;);
                done();
            });
        });

        it(&#039;should error if username is already taken or rename user&#039;, async () =&gt; {
            let err;
            async function tryCreate(data) {
                try {
                    return await User.create(data);
                } catch (_err) {
                    err = _err;
                }
            }

            const [uid1, uid2] = await Promise.all([
                tryCreate({ username: &#039;dupe1&#039; }),
                tryCreate({ username: &#039;dupe1&#039; }),
            ]);
            if (err) {
                assert.strictEqual(err.message, &#039;[[error:username-taken]]&#039;);
            } else {
                const userData = await User.getUsersFields([uid1, uid2], [&#039;username&#039;]);
                const userNames = userData.map(u =&gt; u.username);
                // make sure only 1 dupe1 is created
                assert.equal(userNames.filter(username =&gt; username === &#039;dupe1&#039;).length, 1);
                assert.equal(userNames.filter(username =&gt; username === &#039;dupe1 0&#039;).length, 1);
            }
        });

        it(&#039;should error if email is already taken&#039;, async () =&gt; {
            let err;
            async function tryCreate(data) {
                try {
                    return await User.create(data);
                } catch (_err) {
                    err = _err;
                }
            }

            await Promise.all([
                tryCreate({ username: &#039;notdupe1&#039;, email: &#039;dupe@dupe.com&#039; }),
                tryCreate({ username: &#039;notdupe2&#039;, email: &#039;dupe@dupe.com&#039; }),
            ]);
            assert.strictEqual(err.message, &#039;[[error:email-taken]]&#039;);
        });
    });

    describe(&#039;.uniqueUsername()&#039;, () =&gt; {
        it(&#039;should deal with collisions&#039;, (done) =&gt; {
            const users = [];
            for (let i = 0; i &lt; 10; i += 1) {
                users.push({
                    username: &#039;Jane Doe&#039;,
                    email: `jane.doe${i}@example.com`,
                });
            }

            async.series([
                function (next) {
                    async.eachSeries(users, (user, next) =&gt; {
                        User.create(user, next);
                    }, next);
                },
                function (next) {
                    User.uniqueUsername({
                        username: &#039;Jane Doe&#039;,
                        userslug: &#039;jane-doe&#039;,
                    }, (err, username) =&gt; {
                        assert.ifError(err);

                        assert.strictEqual(username, &#039;Jane Doe 9&#039;);
                        next();
                    });
                },
            ], done);
        });
    });

    describe(&#039;.isModerator()&#039;, () =&gt; {
        it(&#039;should return false&#039;, (done) =&gt; {
            User.isModerator(testUid, testCid, (err, isModerator) =&gt; {
                assert.equal(err, null);
                assert.equal(isModerator, false);
                done();
            });
        });

        it(&#039;should return two false results&#039;, (done) =&gt; {
            User.isModerator([testUid, testUid], testCid, (err, isModerator) =&gt; {
                assert.equal(err, null);
                assert.equal(isModerator[0], false);
                assert.equal(isModerator[1], false);
                done();
            });
        });

        it(&#039;should return two false results&#039;, (done) =&gt; {
            User.isModerator(testUid, [testCid, testCid], (err, isModerator) =&gt; {
                assert.equal(err, null);
                assert.equal(isModerator[0], false);
                assert.equal(isModerator[1], false);
                done();
            });
        });
    });

    describe(&#039;.getModeratorUids()&#039;, () =&gt; {
        before((done) =&gt; {
            groups.join(&#039;cid:1:privileges:moderate&#039;, 1, done);
        });

        it(&#039;should retrieve all users with moderator bit in category privilege&#039;, (done) =&gt; {
            User.getModeratorUids((err, uids) =&gt; {
                assert.ifError(err);
                assert.strictEqual(1, uids.length);
                assert.strictEqual(1, parseInt(uids[0], 10));
                done();
            });
        });

        after((done) =&gt; {
            groups.leave(&#039;cid:1:privileges:moderate&#039;, 1, done);
        });
    });

    describe(&#039;.getModeratorUids()&#039;, () =&gt; {
        before((done) =&gt; {
            async.series([
                async.apply(groups.create, { name: &#039;testGroup&#039; }),
                async.apply(groups.join, &#039;cid:1:privileges:groups:moderate&#039;, &#039;testGroup&#039;),
                async.apply(groups.join, &#039;testGroup&#039;, 1),
            ], done);
        });

        it(&#039;should retrieve all users with moderator bit in category privilege&#039;, (done) =&gt; {
            User.getModeratorUids((err, uids) =&gt; {
                assert.ifError(err);
                assert.strictEqual(1, uids.length);
                assert.strictEqual(1, parseInt(uids[0], 10));
                done();
            });
        });

        after((done) =&gt; {
            async.series([
                async.apply(groups.leave, &#039;cid:1:privileges:groups:moderate&#039;, &#039;testGroup&#039;),
                async.apply(groups.destroy, &#039;testGroup&#039;),
            ], done);
        });
    });

    describe(&#039;.isReadyToPost()&#039;, () =&gt; {
        it(&#039;should error when a user makes two posts in quick succession&#039;, (done) =&gt; {
            meta.config = meta.config || {};
            meta.config.postDelay = &#039;10&#039;;

            async.series([
                async.apply(Topics.post, {
                    uid: testUid,
                    title: &#039;Topic 1&#039;,
                    content: &#039;lorem ipsum&#039;,
                    cid: testCid,
                }),
                async.apply(Topics.post, {
                    uid: testUid,
                    title: &#039;Topic 2&#039;,
                    content: &#039;lorem ipsum&#039;,
                    cid: testCid,
                }),
            ], (err) =&gt; {
                assert(err);
                done();
            });
        });

        it(&#039;should allow a post if the last post time is &gt; 10 seconds&#039;, (done) =&gt; {
            User.setUserField(testUid, &#039;lastposttime&#039;, +new Date() - (11 * 1000), () =&gt; {
                Topics.post({
                    uid: testUid,
                    title: &#039;Topic 3&#039;,
                    content: &#039;lorem ipsum&#039;,
                    cid: testCid,
                }, (err) =&gt; {
                    assert.ifError(err);
                    done();
                });
            });
        });

        it(&#039;should error when a new user posts if the last post time is 10 &lt; 30 seconds&#039;, (done) =&gt; {
            meta.config.newbiePostDelay = 30;
            meta.config.newbiePostDelayThreshold = 3;

            User.setUserField(testUid, &#039;lastposttime&#039;, +new Date() - (20 * 1000), () =&gt; {
                Topics.post({
                    uid: testUid,
                    title: &#039;Topic 4&#039;,
                    content: &#039;lorem ipsum&#039;,
                    cid: testCid,
                }, (err) =&gt; {
                    assert(err);
                    done();
                });
            });
        });

        it(&#039;should not error if a non-newbie user posts if the last post time is 10 &lt; 30 seconds&#039;, (done) =&gt; {
            User.setUserFields(testUid, {
                lastposttime: +new Date() - (20 * 1000),
                reputation: 10,
            }, () =&gt; {
                Topics.post({
                    uid: testUid,
                    title: &#039;Topic 5&#039;,
                    content: &#039;lorem ipsum&#039;,
                    cid: testCid,
                }, (err) =&gt; {
                    assert.ifError(err);
                    done();
                });
            });
        });

        it(&#039;should only post 1 topic out of 10&#039;, async () =&gt; {
            await User.create({ username: &#039;flooder&#039;, password: &#039;123456&#039; });
            const { jar } = await helpers.loginUser(&#039;flooder&#039;, &#039;123456&#039;);
            const titles = new Array(10).fill(&#039;topic title&#039;);
            const res = await Promise.allSettled(titles.map(async (title) =&gt; {
                const { body } = await helpers.request(&#039;post&#039;, &#039;/api/v3/topics&#039;, {
                    form: {
                        cid: testCid,
                        title: title,
                        content: &#039;the content&#039;,
                    },
                    jar: jar,
                    json: true,
                });
                return body.status;
            }));
            const failed = res.filter(res =&gt; res.value.code === &#039;bad-request&#039;);
            const success = res.filter(res =&gt; res.value.code === &#039;ok&#039;);
            assert.strictEqual(failed.length, 9);
            assert.strictEqual(success.length, 1);
        });
    });

    describe(&#039;.search()&#039;, () =&gt; {
        let adminUid;
        let uid;
        before(async () =&gt; {
            adminUid = await User.create({ username: &#039;noteadmin&#039; });
            await groups.join(&#039;administrators&#039;, adminUid);
        });

        it(&#039;should return an object containing an array of matching users&#039;, (done) =&gt; {
            User.search({ query: &#039;john&#039; }, (err, searchData) =&gt; {
                assert.ifError(err);
                uid = searchData.users[0].uid;
                assert.equal(Array.isArray(searchData.users) &amp;&amp; searchData.users.length &gt; 0, true);
                assert.equal(searchData.users[0].username, &#039;John Smith&#039;);
                done();
            });
        });

        it(&#039;should search user&#039;, async () =&gt; {
            const searchData = await apiUser.search({ uid: testUid }, { query: &#039;john&#039; });
            assert.equal(searchData.users[0].username, &#039;John Smith&#039;);
        });

        it(&#039;should error for guest&#039;, async () =&gt; {
            try {
                await apiUser.search({ uid: 0 }, { query: &#039;john&#039; });
                assert(false);
            } catch (err) {
                assert.equal(err.message, &#039;[[error:no-privileges]]&#039;);
            }
        });

        it(&#039;should error with invalid data&#039;, async () =&gt; {
            try {
                await apiUser.search({ uid: testUid }, null);
                assert(false);
            } catch (err) {
                assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
            }
        });

        it(&#039;should error for unprivileged user&#039;, async () =&gt; {
            try {
                await apiUser.search({ uid: testUid }, { searchBy: &#039;ip&#039;, query: &#039;123&#039; });
                assert(false);
            } catch (err) {
                assert.equal(err.message, &#039;[[error:no-privileges]]&#039;);
            }
        });

        it(&#039;should error for unprivileged user&#039;, async () =&gt; {
            try {
                await apiUser.search({ uid: testUid }, { filters: [&#039;banned&#039;], query: &#039;123&#039; });
                assert(false);
            } catch (err) {
                assert.equal(err.message, &#039;[[error:no-privileges]]&#039;);
            }
        });

        it(&#039;should error for unprivileged user&#039;, async () =&gt; {
            try {
                await apiUser.search({ uid: testUid }, { filters: [&#039;flagged&#039;], query: &#039;123&#039; });
                assert(false);
            } catch (err) {
                assert.equal(err.message, &#039;[[error:no-privileges]]&#039;);
            }
        });

        it(&#039;should search users by ip&#039;, async () =&gt; {
            const uid = await User.create({ username: &#039;ipsearch&#039; });
            await db.sortedSetAdd(&#039;ip:1.1.1.1:uid&#039;, [1, 1], [testUid, uid]);
            const data = await apiUser.search({ uid: adminUid }, { query: &#039;1.1.1.1&#039;, searchBy: &#039;ip&#039; });
            assert(Array.isArray(data.users));
            assert.equal(data.users.length, 2);
        });

        it(&#039;should search users by uid&#039;, async () =&gt; {
            const data = await apiUser.search({ uid: testUid }, { query: uid, searchBy: &#039;uid&#039; });
            assert(Array.isArray(data.users));
            assert.equal(data.users[0].uid, uid);
        });

        it(&#039;should search users by fullname&#039;, async () =&gt; {
            const uid = await User.create({ username: &#039;fullnamesearch1&#039;, fullname: &#039;Mr. Fullname&#039; });
            const data = await apiUser.search({ uid: adminUid }, { query: &#039;mr&#039;, searchBy: &#039;fullname&#039; });
            assert(Array.isArray(data.users));
            assert.equal(data.users.length, 1);
            assert.equal(uid, data.users[0].uid);
        });

        it(&#039;should search users by fullname&#039;, async () =&gt; {
            const uid = await User.create({ username: &#039;fullnamesearch2&#039;, fullname: &#039;Baris:Usakli&#039; });
            const data = await apiUser.search({ uid: adminUid }, { query: &#039;baris:&#039;, searchBy: &#039;fullname&#039; });
            assert(Array.isArray(data.users));
            assert.equal(data.users.length, 1);
            assert.equal(uid, data.users[0].uid);
        });

        it(&#039;should return empty array if query is empty&#039;, async () =&gt; {
            const data = await apiUser.search({ uid: testUid }, { query: &#039;&#039; });
            assert.equal(data.users.length, 0);
        });

        it(&#039;should filter users&#039;, async () =&gt; {
            const uid = await User.create({ username: &#039;ipsearch_filter&#039; });
            await User.bans.ban(uid, 0, &#039;&#039;);
            await User.setUserFields(uid, { flags: 10 });
            const data = await apiUser.search({ uid: adminUid }, {
                query: &#039;ipsearch&#039;,
                filters: [&#039;online&#039;, &#039;banned&#039;, &#039;flagged&#039;],
            });
            assert.equal(data.users[0].username, &#039;ipsearch_filter&#039;);
        });

        it(&#039;should sort results by username&#039;, (done) =&gt; {
            async.waterfall([
                function (next) {
                    User.create({ username: &#039;brian&#039; }, next);
                },
                function (uid, next) {
                    User.create({ username: &#039;baris&#039; }, next);
                },
                function (uid, next) {
                    User.create({ username: &#039;bzari&#039; }, next);
                },
                function (uid, next) {
                    User.search({
                        uid: testUid,
                        query: &#039;b&#039;,
                        sortBy: &#039;username&#039;,
                        paginate: false,
                    }, next);
                },
            ], (err, data) =&gt; {
                assert.ifError(err);
                assert.equal(data.users[0].username, &#039;baris&#039;);
                assert.equal(data.users[1].username, &#039;brian&#039;);
                assert.equal(data.users[2].username, &#039;bzari&#039;);
                done();
            });
        });
    });

    describe(&#039;.delete()&#039;, () =&gt; {
        let uid;
        before((done) =&gt; {
            User.create({ username: &#039;usertodelete&#039;, password: &#039;123456&#039;, email: &#039;delete@me.com&#039; }, (err, newUid) =&gt; {
                assert.ifError(err);
                uid = newUid;
                done();
            });
        });

        it(&#039;should delete a user account&#039;, (done) =&gt; {
            User.delete(1, uid, (err) =&gt; {
                assert.ifError(err);
                User.existsBySlug(&#039;usertodelete&#039;, (err, exists) =&gt; {
                    assert.ifError(err);
                    assert.equal(exists, false);
                    done();
                });
            });
        });

        it(&#039;should not re-add user to users:postcount if post is purged after user account deletion&#039;, async () =&gt; {
            const uid = await User.create({ username: &#039;olduserwithposts&#039; });
            assert(await db.isSortedSetMember(&#039;users:postcount&#039;, uid));

            const result = await Topics.post({
                uid: uid,
                title: &#039;old user topic&#039;,
                content: &#039;old user topic post content&#039;,
                cid: testCid,
            });
            assert.equal(await db.sortedSetScore(&#039;users:postcount&#039;, uid), 1);
            await User.deleteAccount(uid);
            assert(!await db.isSortedSetMember(&#039;users:postcount&#039;, uid));
            await Posts.purge(result.postData.pid, 1);
            assert(!await db.isSortedSetMember(&#039;users:postcount&#039;, uid));
        });

        it(&#039;should not re-add user to users:reputation if post is upvoted after user account deletion&#039;, async () =&gt; {
            const uid = await User.create({ username: &#039;olduserwithpostsupvote&#039; });
            assert(await db.isSortedSetMember(&#039;users:reputation&#039;, uid));

            const result = await Topics.post({
                uid: uid,
                title: &#039;old user topic&#039;,
                content: &#039;old user topic post content&#039;,
                cid: testCid,
            });
            assert.equal(await db.sortedSetScore(&#039;users:reputation&#039;, uid), 0);
            await User.deleteAccount(uid);
            assert(!await db.isSortedSetMember(&#039;users:reputation&#039;, uid));
            await Posts.upvote(result.postData.pid, 1);
            assert(!await db.isSortedSetMember(&#039;users:reputation&#039;, uid));
        });

        it(&#039;should delete user even if they started a chat&#039;, async () =&gt; {
            const socketModules = require(&#039;../src/socket.io/modules&#039;);
            const uid1 = await User.create({ username: &#039;chatuserdelete1&#039; });
            const uid2 = await User.create({ username: &#039;chatuserdelete2&#039; });
            const roomId = await messaging.newRoom(uid1, [uid2]);
            await messaging.addMessage({
                uid: uid1,
                content: &#039;hello&#039;,
                roomId,
            });
            await messaging.leaveRoom([uid2], roomId);
            await User.delete(1, uid1);
            assert.strictEqual(await User.exists(uid1), false);
        });
    });

    describe(&#039;passwordReset&#039;, () =&gt; {
        let uid;
        let code;
        before(async () =&gt; {
            uid = await User.create({ username: &#039;resetuser&#039;, password: &#039;123456&#039; });
            await User.setUserField(uid, &#039;email&#039;, &#039;reset@me.com&#039;);
            await User.email.confirmByUid(uid);
        });

        it(&#039;.generate() should generate a new reset code&#039;, (done) =&gt; {
            User.reset.generate(uid, (err, _code) =&gt; {
                assert.ifError(err);
                assert(_code);

                code = _code;
                done();
            });
        });

        it(&#039;.generate() should invalidate a previous generated reset code&#039;, async () =&gt; {
            const _code = await User.reset.generate(uid);
            const valid = await User.reset.validate(code);
            assert.strictEqual(valid, false);

            code = _code;
        });

        it(&#039;.validate() should ensure that this new code is valid&#039;, (done) =&gt; {
            User.reset.validate(code, (err, valid) =&gt; {
                assert.ifError(err);
                assert.strictEqual(valid, true);
                done();
            });
        });

        it(&#039;.validate() should correctly identify an invalid code&#039;, (done) =&gt; {
            User.reset.validate(`${code}abcdef`, (err, valid) =&gt; {
                assert.ifError(err);
                assert.strictEqual(valid, false);
                done();
            });
        });

        it(&#039;.send() should create a new reset code and reset password&#039;, async () =&gt; {
            code = await User.reset.send(&#039;reset@me.com&#039;);
        });

        it(&#039;.commit() should update the user\&#039;s password and confirm their email&#039;, (done) =&gt; {
            User.reset.commit(code, &#039;newpassword&#039;, (err) =&gt; {
                assert.ifError(err);

                async.parallel({
                    userData: function (next) {
                        User.getUserData(uid, next);
                    },
                    password: function (next) {
                        db.getObjectField(`user:${uid}`, &#039;password&#039;, next);
                    },
                }, (err, results) =&gt; {
                    assert.ifError(err);
                    Password.compare(&#039;newpassword&#039;, results.password, true, (err, match) =&gt; {
                        assert.ifError(err);
                        assert(match);
                        assert.strictEqual(results.userData[&#039;email:confirmed&#039;], 1);
                        done();
                    });
                });
            });
        });

        it(&#039;.should error if same password is used for reset&#039;, async () =&gt; {
            const uid = await User.create({ username: &#039;badmemory&#039;, email: &#039;bad@memory.com&#039;, password: &#039;123456&#039; });
            const code = await User.reset.generate(uid);
            let err;
            try {
                await User.reset.commit(code, &#039;123456&#039;);
            } catch (_err) {
                err = _err;
            }
            assert.strictEqual(err.message, &#039;[[error:reset-same-password]]&#039;);
        });

        it(&#039;should not validate email if password reset is due to expiry&#039;, async () =&gt; {
            const uid = await User.create({ username: &#039;resetexpiry&#039;, email: &#039;reset@expiry.com&#039;, password: &#039;123456&#039; });
            let confirmed = await User.getUserField(uid, &#039;email:confirmed&#039;);
            let [verified, unverified] = await groups.isMemberOfGroups(uid, [&#039;verified-users&#039;, &#039;unverified-users&#039;]);
            assert.strictEqual(confirmed, 0);
            assert.strictEqual(verified, false);
            assert.strictEqual(unverified, true);
            await User.setUserField(uid, &#039;passwordExpiry&#039;, Date.now());
            const code = await User.reset.generate(uid);
            await User.reset.commit(code, &#039;654321&#039;);
            confirmed = await User.getUserField(uid, &#039;email:confirmed&#039;);
            [verified, unverified] = await groups.isMemberOfGroups(uid, [&#039;verified-users&#039;, &#039;unverified-users&#039;]);
            assert.strictEqual(confirmed, 0);
            assert.strictEqual(verified, false);
            assert.strictEqual(unverified, true);
        });
    });

    describe(&#039;hash methods&#039;, () =&gt; {
        it(&#039;should return uid from email&#039;, (done) =&gt; {
            User.getUidByEmail(&#039;john@example.com&#039;, (err, uid) =&gt; {
                assert.ifError(err);
                assert.equal(parseInt(uid, 10), parseInt(testUid, 10));
                done();
            });
        });

        it(&#039;should return uid from username&#039;, (done) =&gt; {
            User.getUidByUsername(&#039;John Smith&#039;, (err, uid) =&gt; {
                assert.ifError(err);
                assert.equal(parseInt(uid, 10), parseInt(testUid, 10));
                done();
            });
        });

        it(&#039;should return uid from userslug&#039;, (done) =&gt; {
            User.getUidByUserslug(&#039;john-smith&#039;, (err, uid) =&gt; {
                assert.ifError(err);
                assert.equal(parseInt(uid, 10), parseInt(testUid, 10));
                done();
            });
        });

        it(&#039;should get user data even if one uid is NaN&#039;, (done) =&gt; {
            User.getUsersData([NaN, testUid], (err, data) =&gt; {
                assert.ifError(err);
                assert(data[0]);
                assert.equal(data[0].username, &#039;[[global:guest]]&#039;);
                assert(data[1]);
                assert.equal(data[1].username, userData.username);
                done();
            });
        });

        it(&#039;should not return private user data&#039;, (done) =&gt; {
            User.setUserFields(testUid, {
                fb_token: &#039;123123123&#039;,
                another_secret: &#039;abcde&#039;,
                postcount: &#039;123&#039;,
            }, (err) =&gt; {
                assert.ifError(err);
                User.getUserData(testUid, (err, userData) =&gt; {
                    assert.ifError(err);
                    assert(!userData.hasOwnProperty(&#039;fb_token&#039;));
                    assert(!userData.hasOwnProperty(&#039;another_secret&#039;));
                    assert(!userData.hasOwnProperty(&#039;password&#039;));
                    assert(!userData.hasOwnProperty(&#039;rss_token&#039;));
                    assert.strictEqual(userData.postcount, 123);
                    assert.strictEqual(userData.uid, testUid);
                    done();
                });
            });
        });

        it(&#039;should not return password even if explicitly requested&#039;, (done) =&gt; {
            User.getUserFields(testUid, [&#039;password&#039;], (err, payload) =&gt; {
                assert.ifError(err);
                assert(!payload.hasOwnProperty(&#039;password&#039;));
                done();
            });
        });

        it(&#039;should not modify the fields array passed in&#039;, async () =&gt; {
            const fields = [&#039;username&#039;, &#039;email&#039;];
            await User.getUserFields(testUid, fields);
            assert.deepStrictEqual(fields, [&#039;username&#039;, &#039;email&#039;]);
        });

        it(&#039;should return an icon text and valid background if username and picture is explicitly requested&#039;, async () =&gt; {
            const payload = await User.getUserFields(testUid, [&#039;username&#039;, &#039;picture&#039;]);
            const validBackgrounds = await User.getIconBackgrounds(testUid);
            assert.strictEqual(payload[&#039;icon:text&#039;], userData.username.slice(0, 1).toUpperCase());
            assert(payload[&#039;icon:bgColor&#039;]);
            assert(validBackgrounds.includes(payload[&#039;icon:bgColor&#039;]));
        });

        it(&#039;should return a valid background, even if an invalid background colour is set&#039;, async () =&gt; {
            await User.setUserField(testUid, &#039;icon:bgColor&#039;, &#039;teal&#039;);
            const payload = await User.getUserFields(testUid, [&#039;username&#039;, &#039;picture&#039;]);
            const validBackgrounds = await User.getIconBackgrounds(testUid);

            assert(payload[&#039;icon:bgColor&#039;]);
            assert(validBackgrounds.includes(payload[&#039;icon:bgColor&#039;]));
        });

        it(&#039;should return private data if field is whitelisted&#039;, (done) =&gt; {
            function filterMethod(data, callback) {
                data.whitelist.push(&#039;another_secret&#039;);
                callback(null, data);
            }

            plugins.hooks.register(&#039;test-plugin&#039;, { hook: &#039;filter:user.whitelistFields&#039;, method: filterMethod });
            User.getUserData(testUid, (err, userData) =&gt; {
                assert.ifError(err);
                assert(!userData.hasOwnProperty(&#039;fb_token&#039;));
                assert.equal(userData.another_secret, &#039;abcde&#039;);
                plugins.hooks.unregister(&#039;test-plugin&#039;, &#039;filter:user.whitelistFields&#039;, filterMethod);
                done();
            });
        });

        it(&#039;should return 0 as uid if username is falsy&#039;, (done) =&gt; {
            User.getUidByUsername(&#039;&#039;, (err, uid) =&gt; {
                assert.ifError(err);
                assert.strictEqual(uid, 0);
                done();
            });
        });

        it(&#039;should get username by userslug&#039;, (done) =&gt; {
            User.getUsernameByUserslug(&#039;john-smith&#039;, (err, username) =&gt; {
                assert.ifError(err);
                assert.strictEqual(&#039;John Smith&#039;, username);
                done();
            });
        });

        it(&#039;should get uids by emails&#039;, (done) =&gt; {
            User.getUidsByEmails([&#039;john@example.com&#039;], (err, uids) =&gt; {
                assert.ifError(err);
                assert.equal(uids[0], testUid);
                done();
            });
        });

        it(&#039;should not get groupTitle for guests&#039;, (done) =&gt; {
            User.getUserData(0, (err, userData) =&gt; {
                assert.ifError(err);
                assert.strictEqual(userData.groupTitle, &#039;&#039;);
                assert.deepStrictEqual(userData.groupTitleArray, []);
                done();
            });
        });

        it(&#039;should load guest data&#039;, (done) =&gt; {
            User.getUsersData([1, 0], (err, data) =&gt; {
                assert.ifError(err);
                assert.strictEqual(data[1].username, &#039;[[global:guest]]&#039;);
                assert.strictEqual(data[1].userslug, &#039;&#039;);
                assert.strictEqual(data[1].uid, 0);
                done();
            });
        });
    });

    describe(&#039;profile methods&#039;, () =&gt; {
        let uid;
        let jar;
        let csrf_token;

        before(async () =&gt; {
            const newUid = await User.create({ username: &#039;updateprofile&#039;, email: &#039;update@me.com&#039;, password: &#039;123456&#039; });
            uid = newUid;

            await User.setUserField(uid, &#039;email&#039;, &#039;update@me.com&#039;);
            await User.email.confirmByUid(uid);

            ({ jar, csrf_token } = await helpers.loginUser(&#039;updateprofile&#039;, &#039;123456&#039;));
        });

        it(&#039;should return error if not logged in&#039;, async () =&gt; {
            try {
                await apiUser.update({ uid: 0 }, { uid: 1 });
                assert(false);
            } catch (err) {
                assert.equal(err.message, &#039;[[error:invalid-uid]]&#039;);
            }
        });

        it(&#039;should return error if data is invalid&#039;, async () =&gt; {
            try {
                await apiUser.update({ uid: uid }, null);
                assert(false);
            } catch (err) {
                assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
            }
        });

        it(&#039;should return error if data is missing uid&#039;, async () =&gt; {
            try {
                await apiUser.update({ uid: uid }, { username: &#039;bip&#039;, email: &#039;bop&#039; });
                assert(false);
            } catch (err) {
                assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
            }
        });

        describe(&#039;.updateProfile()&#039;, () =&gt; {
            let uid;

            it(&#039;should update a user\&#039;s profile&#039;, async () =&gt; {
                uid = await User.create({ username: &#039;justforupdate&#039;, email: &#039;just@for.updated&#039;, password: &#039;123456&#039; });
                await User.setUserField(uid, &#039;email&#039;, &#039;just@for.updated&#039;);
                await User.email.confirmByUid(uid);

                const data = {
                    uid: uid,
                    username: &#039;updatedUserName&#039;,
                    email: &#039;updatedEmail@me.com&#039;,
                    fullname: &#039;updatedFullname&#039;,
                    website: &#039;http://nodebb.org&#039;,
                    location: &#039;izmir&#039;,
                    groupTitle: &#039;testGroup&#039;,
                    birthday: &#039;01/01/1980&#039;,
                    signature: &#039;nodebb is good&#039;,
                    password: &#039;123456&#039;,
                };
                const result = await apiUser.update({ uid: uid }, { ...data, password: &#039;123456&#039;, invalid: &#039;field&#039; });
                assert.equal(result.username, &#039;updatedUserName&#039;);
                assert.equal(result.userslug, &#039;updatedusername&#039;);
                assert.equal(result.location, &#039;izmir&#039;);

                const userData = await db.getObject(`user:${uid}`);
                Object.keys(data).forEach((key) =&gt; {
                    if (key === &#039;email&#039;) {
                        assert.strictEqual(userData.email, &#039;just@for.updated&#039;); // email remains the same until confirmed
                    } else if (key !== &#039;password&#039;) {
                        assert.equal(data[key], userData[key]);
                    } else {
                        assert(userData[key].startsWith(&#039;$2a$&#039;));
                    }
                });
                // updateProfile only saves valid fields
                assert.strictEqual(userData.invalid, undefined);
            });

            it(&#039;should also generate an email confirmation code for the changed email&#039;, async () =&gt; {
                const confirmSent = await User.email.isValidationPending(uid, &#039;updatedemail@me.com&#039;);
                assert.strictEqual(confirmSent, true);
            });
        });

        it(&#039;should change a user\&#039;s password&#039;, async () =&gt; {
            const uid = await User.create({ username: &#039;changepassword&#039;, password: &#039;123456&#039; });
            await apiUser.changePassword({ uid: uid }, { uid: uid, newPassword: &#039;654321&#039;, currentPassword: &#039;123456&#039; });
            const correct = await User.isPasswordCorrect(uid, &#039;654321&#039;, &#039;127.0.0.1&#039;);
            assert(correct);
        });

        it(&#039;should not let user change another user\&#039;s password&#039;, async () =&gt; {
            const regularUserUid = await User.create({ username: &#039;regularuserpwdchange&#039;, password: &#039;regularuser1234&#039; });
            const uid = await User.create({ username: &#039;changeadminpwd1&#039;, password: &#039;123456&#039; });
            try {
                await apiUser.changePassword({ uid: uid }, { uid: regularUserUid, newPassword: &#039;654321&#039;, currentPassword: &#039;123456&#039; });
                assert(false);
            } catch (err) {
                assert.equal(err.message, &#039;[[user:change_password_error_privileges]]&#039;);
            }
        });

        it(&#039;should not let user change admin\&#039;s password&#039;, async () =&gt; {
            const adminUid = await User.create({ username: &#039;adminpwdchange&#039;, password: &#039;admin1234&#039; });
            await groups.join(&#039;administrators&#039;, adminUid);
            const uid = await User.create({ username: &#039;changeadminpwd2&#039;, password: &#039;123456&#039; });
            try {
                await apiUser.changePassword({ uid: uid }, { uid: adminUid, newPassword: &#039;654321&#039;, currentPassword: &#039;123456&#039; });
                assert(false);
            } catch (err) {
                assert.equal(err.message, &#039;[[user:change_password_error_privileges]]&#039;);
            }
        });

        it(&#039;should let admin change another users password&#039;, async () =&gt; {
            const adminUid = await User.create({ username: &#039;adminpwdchange2&#039;, password: &#039;admin1234&#039; });
            await groups.join(&#039;administrators&#039;, adminUid);
            const uid = await User.create({ username: &#039;forgotmypassword&#039;, password: &#039;123456&#039; });

            await apiUser.changePassword({ uid: adminUid }, { uid: uid, newPassword: &#039;654321&#039; });
            const correct = await User.isPasswordCorrect(uid, &#039;654321&#039;, &#039;127.0.0.1&#039;);
            assert(correct);
        });

        it(&#039;should not let admin change their password if current password is incorrect&#039;, async () =&gt; {
            const adminUid = await User.create({ username: &#039;adminforgotpwd&#039;, password: &#039;admin1234&#039; });
            await groups.join(&#039;administrators&#039;, adminUid);

            try {
                await apiUser.changePassword({ uid: adminUid }, { uid: adminUid, newPassword: &#039;654321&#039;, currentPassword: &#039;wrongpwd&#039; });
                assert(false);
            } catch (err) {
                assert.equal(err.message, &#039;[[user:change_password_error_wrong_current]]&#039;);
            }
        });

        it(&#039;should change username&#039;, async () =&gt; {
            await apiUser.update({ uid: uid }, { uid: uid, username: &#039;updatedAgain&#039;, password: &#039;123456&#039; });
            const username = await db.getObjectField(`user:${uid}`, &#039;username&#039;);
            assert.equal(username, &#039;updatedAgain&#039;);
        });

        it(&#039;should not let setting an empty username&#039;, async () =&gt; {
            await apiUser.update({ uid: uid }, { uid: uid, username: &#039;&#039;, password: &#039;123456&#039; });
            const username = await db.getObjectField(`user:${uid}`, &#039;username&#039;);
            assert.strictEqual(username, &#039;updatedAgain&#039;);
        });

        it(&#039;should let updating profile if current username is above max length and it is not being changed&#039;, async () =&gt; {
            const maxLength = meta.config.maximumUsernameLength + 1;
            const longName = new Array(maxLength).fill(&#039;a&#039;).join(&#039;&#039;);
            const uid = await User.create({ username: longName });
            await apiUser.update({ uid: uid }, { uid: uid, username: longName, email: &#039;verylong@name.com&#039; });
            const userData = await db.getObject(`user:${uid}`);
            const awaitingValidation = await User.email.isValidationPending(uid, &#039;verylong@name.com&#039;);

            assert.strictEqual(userData.username, longName);
            assert.strictEqual(awaitingValidation, true);
        });

        it(&#039;should not update a user\&#039;s username if it did not change&#039;, async () =&gt; {
            await apiUser.update({ uid: uid }, { uid: uid, username: &#039;updatedAgain&#039;, password: &#039;123456&#039; });
            const data = await db.getSortedSetRevRange(`user:${uid}:usernames`, 0, -1);
            assert.equal(data.length, 2);
            assert(data[0].startsWith(&#039;updatedAgain&#039;));
        });

        it(&#039;should not update a user\&#039;s username if a password is not supplied&#039;, async () =&gt; {
            try {
                await apiUser.update({ uid: uid }, { uid: uid, username: &#039;updatedAgain&#039;, password: &#039;&#039; });
                assert(false);
            } catch (err) {
                assert.strictEqual(err.message, &#039;[[error:invalid-password]]&#039;);
            }
        });

        it(&#039;should send validation email&#039;, async () =&gt; {
            const uid = await User.create({ username: &#039;pooremailupdate&#039;, email: &#039;poor@update.me&#039;, password: &#039;123456&#039; });
            await User.email.expireValidation(uid);
            await apiUser.update({ uid: uid }, { uid: uid, email: &#039;updatedAgain@me.com&#039;, password: &#039;123456&#039; });

            assert.strictEqual(await User.email.isValidationPending(uid, &#039;updatedAgain@me.com&#039;.toLowerCase()), true);
        });

        it(&#039;should update cover image&#039;, (done) =&gt; {
            const position = &#039;50.0301% 19.2464%&#039;;
            const coverData = { uid: uid, imageData: goodImage, position: position };
            socketUser.updateCover({ uid: uid }, coverData, (err, result) =&gt; {
                assert.ifError(err);
                assert(result.url);
                db.getObjectFields(`user:${uid}`, [&#039;cover:url&#039;, &#039;cover:position&#039;], (err, data) =&gt; {
                    assert.ifError(err);
                    assert.equal(data[&#039;cover:url&#039;], result.url);
                    assert.equal(data[&#039;cover:position&#039;], position);
                    done();
                });
            });
        });

        it(&#039;should remove cover image&#039;, async () =&gt; {
            const coverPath = await User.getLocalCoverPath(uid);
            await socketUser.removeCover({ uid: uid }, { uid: uid });
            const coverUrlNow = await db.getObjectField(`user:${uid}`, &#039;cover:url&#039;);
            assert.strictEqual(coverUrlNow, null);
            assert.strictEqual(fs.existsSync(coverPath), false);
        });

        it(&#039;should set user status&#039;, (done) =&gt; {
            socketUser.setStatus({ uid: uid }, &#039;away&#039;, (err, data) =&gt; {
                assert.ifError(err);
                assert.equal(data.uid, uid);
                assert.equal(data.status, &#039;away&#039;);
                done();
            });
        });

        it(&#039;should fail for invalid status&#039;, (done) =&gt; {
            socketUser.setStatus({ uid: uid }, &#039;12345&#039;, (err) =&gt; {
                assert.equal(err.message, &#039;[[error:invalid-user-status]]&#039;);
                done();
            });
        });

        it(&#039;should get user status&#039;, (done) =&gt; {
            socketUser.checkStatus({ uid: uid }, uid, (err, status) =&gt; {
                assert.ifError(err);
                assert.equal(status, &#039;away&#039;);
                done();
            });
        });

        it(&#039;should change user picture&#039;, async () =&gt; {
            await apiUser.changePicture({ uid: uid }, { type: &#039;default&#039;, uid: uid });
            const picture = await User.getUserField(uid, &#039;picture&#039;);
            assert.equal(picture, &#039;&#039;);
        });

        it(&#039;should let you set an external image&#039;, async () =&gt; {
            const token = await helpers.getCsrfToken(jar);
            const body = await requestAsync(`${nconf.get(&#039;url&#039;)}/api/v3/users/${uid}/picture`, {
                jar,
                method: &#039;put&#039;,
                json: true,
                headers: {
                    &#039;x-csrf-token&#039;: token,
                },
                body: {
                    type: &#039;external&#039;,
                    url: &#039;https://example.org/picture.jpg&#039;,
                },
            });

            assert(body &amp;&amp; body.status &amp;&amp; body.response);
            assert.strictEqual(body.status.code, &#039;ok&#039;);

            const picture = await User.getUserField(uid, &#039;picture&#039;);
            assert.strictEqual(picture, validator.escape(&#039;https://example.org/picture.jpg&#039;));
        });

        it(&#039;should fail to change user picture with invalid data&#039;, async () =&gt; {
            try {
                await apiUser.changePicture({ uid: uid }, null);
                assert(false);
            } catch (err) {
                assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
            }
        });

        it(&#039;should fail to change user picture with invalid uid&#039;, async () =&gt; {
            try {
                await apiUser.changePicture({ uid: 0 }, { uid: 1 });
                assert(false);
            } catch (err) {
                assert.equal(err.message, &#039;[[error:no-privileges]]&#039;);
            }
        });

        it(&#039;should set user picture to uploaded&#039;, async () =&gt; {
            await User.setUserField(uid, &#039;uploadedpicture&#039;, &#039;/test&#039;);
            await apiUser.changePicture({ uid: uid }, { type: &#039;uploaded&#039;, uid: uid });
            const picture = await User.getUserField(uid, &#039;picture&#039;);
            assert.equal(picture, `${nconf.get(&#039;relative_path&#039;)}/test`);
        });

        it(&#039;should return error if profile image uploads disabled&#039;, (done) =&gt; {
            meta.config.allowProfileImageUploads = 0;
            const picture = {
                path: path.join(nconf.get(&#039;base_dir&#039;), &#039;test/files/test_copy.png&#039;),
                size: 7189,
                name: &#039;test.png&#039;,
                type: &#039;image/png&#039;,
            };
            User.uploadCroppedPicture({
                callerUid: uid,
                uid: uid,
                file: picture,
            }, (err) =&gt; {
                assert.equal(err.message, &#039;[[error:profile-image-uploads-disabled]]&#039;);
                meta.config.allowProfileImageUploads = 1;
                done();
            });
        });

        it(&#039;should return error if profile image has no mime type&#039;, (done) =&gt; {
            User.uploadCroppedPicture({
                callerUid: uid,
                uid: uid,
                imageData: &#039;data:image/invalid;base64,R0lGODlhPQBEAPeoAJosM/&#039;,
            }, (err) =&gt; {
                assert.equal(err.message, &#039;[[error:invalid-image]]&#039;);
                done();
            });
        });

        describe(&#039;user.uploadCroppedPicture&#039;, () =&gt; {
            const badImage = &#039;data:audio/mp3;base64,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&#039;;

            it(&#039;should upload cropped profile picture&#039;, async () =&gt; {
                const result = await socketUser.uploadCroppedPicture({ uid: uid }, { uid: uid, imageData: goodImage });
                assert(result.url);
                const data = await db.getObjectFields(`user:${uid}`, [&#039;uploadedpicture&#039;, &#039;picture&#039;]);
                assert.strictEqual(result.url, data.uploadedpicture);
                assert.strictEqual(result.url, data.picture);
            });

            it(&#039;should upload cropped profile picture in chunks&#039;, async () =&gt; {
                const socketUploads = require(&#039;../src/socket.io/uploads&#039;);
                const socketData = {
                    uid,
                    method: &#039;user.uploadCroppedPicture&#039;,
                    size: goodImage.length,
                    progress: 0,
                };
                const chunkSize = 1000;
                let result;
                do {
                    const chunk = goodImage.slice(socketData.progress, socketData.progress + chunkSize);
                    socketData.progress += chunk.length;
                    // eslint-disable-next-line
                    result = await socketUploads.upload({ uid: uid }, {
                        chunk: chunk,
                        params: socketData,
                    });
                } while (socketData.progress &lt; socketData.size);

                assert(result.url);
                const data = await db.getObjectFields(`user:${uid}`, [&#039;uploadedpicture&#039;, &#039;picture&#039;]);
                assert.strictEqual(result.url, data.uploadedpicture);
                assert.strictEqual(result.url, data.picture);
            });

            it(&#039;should error if both file and imageData are missing&#039;, (done) =&gt; {
                User.uploadCroppedPicture({}, (err) =&gt; {
                    assert.equal(&#039;[[error:invalid-data]]&#039;, err.message);
                    done();
                });
            });

            it(&#039;should error if file size is too big&#039;, (done) =&gt; {
                const temp = meta.config.maximumProfileImageSize;
                meta.config.maximumProfileImageSize = 1;
                User.uploadCroppedPicture({
                    callerUid: uid,
                    uid: 1,
                    imageData: goodImage,
                }, (err) =&gt; {
                    assert.equal(&#039;[[error:file-too-big, 1]]&#039;, err.message);

                    // Restore old value
                    meta.config.maximumProfileImageSize = temp;
                    done();
                });
            });

            it(&#039;should not allow image data with bad MIME type to be passed in&#039;, (done) =&gt; {
                User.uploadCroppedPicture({
                    callerUid: uid,
                    uid: 1,
                    imageData: badImage,
                }, (err) =&gt; {
                    assert.equal(&#039;[[error:invalid-image]]&#039;, err.message);
                    done();
                });
            });

            it(&#039;should get profile pictures&#039;, (done) =&gt; {
                socketUser.getProfilePictures({ uid: uid }, { uid: uid }, (err, data) =&gt; {
                    assert.ifError(err);
                    assert(data);
                    assert(Array.isArray(data));
                    assert.equal(data[0].type, &#039;uploaded&#039;);
                    assert.equal(data[0].text, &#039;[[user:uploaded_picture]]&#039;);
                    done();
                });
            });

            it(&#039;should get default profile avatar&#039;, (done) =&gt; {
                assert.strictEqual(User.getDefaultAvatar(), &#039;&#039;);
                meta.config.defaultAvatar = &#039;https://path/to/default/avatar&#039;;
                assert.strictEqual(User.getDefaultAvatar(), meta.config.defaultAvatar);
                meta.config.defaultAvatar = &#039;/path/to/default/avatar&#039;;
                assert.strictEqual(User.getDefaultAvatar(), nconf.get(&#039;relative_path&#039;) + meta.config.defaultAvatar);
                meta.config.defaultAvatar = &#039;&#039;;
                done();
            });

            it(&#039;should fail to get profile pictures with invalid data&#039;, (done) =&gt; {
                socketUser.getProfilePictures({ uid: uid }, null, (err) =&gt; {
                    assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
                    socketUser.getProfilePictures({ uid: uid }, { uid: null }, (err) =&gt; {
                        assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
                        done();
                    });
                });
            });

            it(&#039;should remove uploaded picture&#039;, async () =&gt; {
                const avatarPath = await User.getLocalAvatarPath(uid);
                assert.notStrictEqual(avatarPath, false);
                await socketUser.removeUploadedPicture({ uid: uid }, { uid: uid });
                const uploadedPicture = await User.getUserField(uid, &#039;uploadedpicture&#039;);
                assert.strictEqual(uploadedPicture, &#039;&#039;);
                assert.strictEqual(fs.existsSync(avatarPath), false);
            });

            it(&#039;should fail to remove uploaded picture with invalid-data&#039;, (done) =&gt; {
                socketUser.removeUploadedPicture({ uid: uid }, null, (err) =&gt; {
                    assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
                    socketUser.removeUploadedPicture({ uid: uid }, { }, (err) =&gt; {
                        assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
                        socketUser.removeUploadedPicture({ uid: null }, { }, (err) =&gt; {
                            assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
                            done();
                        });
                    });
                });
            });
        });

        it(&#039;should load profile page&#039;, (done) =&gt; {
            request(`${nconf.get(&#039;url&#039;)}/api/user/updatedagain`, { jar: jar, json: true }, (err, res, body) =&gt; {
                assert.ifError(err);
                assert.equal(res.statusCode, 200);
                assert(body);
                done();
            });
        });

        it(&#039;should load settings page&#039;, (done) =&gt; {
            request(`${nconf.get(&#039;url&#039;)}/api/user/updatedagain/settings`, { jar: jar, json: true }, (err, res, body) =&gt; {
                assert.ifError(err);
                assert.equal(res.statusCode, 200);
                assert(body.settings);
                assert(body.languages);
                assert(body.homePageRoutes);
                done();
            });
        });

        it(&#039;should load edit page&#039;, (done) =&gt; {
            request(`${nconf.get(&#039;url&#039;)}/api/user/updatedagain/edit`, { jar: jar, json: true }, (err, res, body) =&gt; {
                assert.ifError(err);
                assert.equal(res.statusCode, 200);
                assert(body);
                done();
            });
        });

        it(&#039;should load edit/email page&#039;, async () =&gt; {
            const res = await requestAsync(`${nconf.get(&#039;url&#039;)}/api/user/updatedagain/edit/email`, { jar: jar, json: true, resolveWithFullResponse: true });
            assert.strictEqual(res.statusCode, 200);
            assert(res.body);

            // Accessing this page will mark the user&#039;s account as needing an updated email, below code undo&#039;s.
            await requestAsync({
                uri: `${nconf.get(&#039;url&#039;)}/register/abort?_csrf=${csrf_token}`,
                jar,
                method: &#039;POST&#039;,
                simple: false,
            });
        });

        it(&#039;should load user\&#039;s groups page&#039;, async () =&gt; {
            await groups.create({
                name: &#039;Test&#039;,
                description: &#039;Foobar!&#039;,
            });

            await groups.join(&#039;Test&#039;, uid);
            const body = await requestAsync(`${nconf.get(&#039;url&#039;)}/api/user/updatedagain/groups`, { jar: jar, json: true });

            assert(Array.isArray(body.groups));
            assert.equal(body.groups[0].name, &#039;Test&#039;);
        });
    });

    describe(&#039;user info&#039;, () =&gt; {
        let testUserUid;
        let verifiedTestUserUid;

        before(async () =&gt; {
            // Might be the first user thus a verified one if this test part is ran alone
            verifiedTestUserUid = await User.create({ username: &#039;bannedUser&#039;, password: &#039;123456&#039;, email: &#039;banneduser@example.com&#039; });
            await User.setUserField(verifiedTestUserUid, &#039;email:confirmed&#039;, 1);
            testUserUid = await User.create({ username: &#039;bannedUser2&#039;, password: &#039;123456&#039;, email: &#039;banneduser2@example.com&#039; });
        });

        it(&#039;should return error if there is no ban reason&#039;, (done) =&gt; {
            User.getLatestBanInfo(123, (err) =&gt; {
                assert.equal(err.message, &#039;no-ban-info&#039;);
                done();
            });
        });

        it(&#039;should get history from set&#039;, async () =&gt; {
            const now = Date.now();
            await db.sortedSetAdd(`user:${testUserUid}:usernames`, now, `derp:${now}`);
            const data = await User.getHistory(`user:${testUserUid}:usernames`);
            assert.equal(data[0].value, &#039;derp&#039;);
            assert.equal(data[0].timestamp, now);
        });

        it(&#039;should return the correct ban reason&#039;, (done) =&gt; {
            async.series([
                function (next) {
                    User.bans.ban(testUserUid, 0, &#039;&#039;, (err) =&gt; {
                        assert.ifError(err);
                        next(err);
                    });
                },
                function (next) {
                    User.getModerationHistory(testUserUid, (err, data) =&gt; {
                        assert.ifError(err);
                        assert.equal(data.bans.length, 1, &#039;one ban&#039;);
                        assert.equal(data.bans[0].reason, &#039;[[user:info.banned-no-reason]]&#039;, &#039;no ban reason&#039;);

                        next(err);
                    });
                },
            ], (err) =&gt; {
                assert.ifError(err);
                User.bans.unban(testUserUid, (err) =&gt; {
                    assert.ifError(err);
                    done();
                });
            });
        });

        it(&#039;should ban user permanently&#039;, (done) =&gt; {
            User.bans.ban(testUserUid, (err) =&gt; {
                assert.ifError(err);
                User.bans.isBanned(testUserUid, (err, isBanned) =&gt; {
                    assert.ifError(err);
                    assert.equal(isBanned, true);
                    User.bans.unban(testUserUid, done);
                });
            });
        });

        it(&#039;should ban user temporarily&#039;, (done) =&gt; {
            User.bans.ban(testUserUid, Date.now() + 2000, (err) =&gt; {
                assert.ifError(err);

                User.bans.isBanned(testUserUid, (err, isBanned) =&gt; {
                    assert.ifError(err);
                    assert.equal(isBanned, true);
                    setTimeout(() =&gt; {
                        User.bans.isBanned(testUserUid, (err, isBanned) =&gt; {
                            assert.ifError(err);
                            assert.equal(isBanned, false);
                            User.bans.unban(testUserUid, done);
                        });
                    }, 3000);
                });
            });
        });

        it(&#039;should error if until is NaN&#039;, (done) =&gt; {
            User.bans.ban(testUserUid, &#039;asd&#039;, (err) =&gt; {
                assert.equal(err.message, &#039;[[error:ban-expiry-missing]]&#039;);
                done();
            });
        });

        it(&#039;should be member of &quot;banned-users&quot; system group only after a ban&#039;, async () =&gt; {
            await User.bans.ban(testUserUid);

            const systemGroups = groups.systemGroups.filter(group =&gt; group !== groups.BANNED_USERS);
            const isMember = await groups.isMember(testUserUid, groups.BANNED_USERS);
            const isMemberOfAny = await groups.isMemberOfAny(testUserUid, systemGroups);

            assert.strictEqual(isMember, true);
            assert.strictEqual(isMemberOfAny, false);
        });

        it(&#039;should restore system group memberships after an unban (for an unverified user)&#039;, async () =&gt; {
            await User.bans.unban(testUserUid);

            const isMemberOfGroups = await groups.isMemberOfGroups(testUserUid, groups.systemGroups);
            const membership = new Map(groups.systemGroups.map((item, index) =&gt; [item, isMemberOfGroups[index]]));

            assert.strictEqual(membership.get(&#039;registered-users&#039;), true);
            assert.strictEqual(membership.get(&#039;verified-users&#039;), false);
            assert.strictEqual(membership.get(&#039;unverified-users&#039;), true);
            assert.strictEqual(membership.get(groups.BANNED_USERS), false);
            // administrators cannot be banned
            assert.strictEqual(membership.get(&#039;administrators&#039;), false);
            // This will not restored
            assert.strictEqual(membership.get(&#039;Global Moderators&#039;), false);
        });

        it(&#039;should restore system group memberships after an unban (for a verified user)&#039;, async () =&gt; {
            await User.bans.ban(verifiedTestUserUid);
            await User.bans.unban(verifiedTestUserUid);

            const isMemberOfGroups = await groups.isMemberOfGroups(verifiedTestUserUid, groups.systemGroups);
            const membership = new Map(groups.systemGroups.map((item, index) =&gt; [item, isMemberOfGroups[index]]));

            assert.strictEqual(membership.get(&#039;verified-users&#039;), true);
            assert.strictEqual(membership.get(&#039;unverified-users&#039;), false);
        });

        it(&#039;should be able to post in category for banned users&#039;, async () =&gt; {
            const { cid } = await Categories.create({
                name: &#039;Test Category&#039;,
                description: &#039;A test&#039;,
                order: 1,
            });
            const testUid = await User.create({ username: userData.username });
            await User.bans.ban(testUid);
            let _err;
            try {
                await Topics.post({ title: &#039;banned topic&#039;, content: &#039;tttttttttttt&#039;, cid: cid, uid: testUid });
            } catch (err) {
                _err = err;
            }
            assert.strictEqual(_err &amp;&amp; _err.message, &#039;[[error:no-privileges]]&#039;);

            await Promise.all([
                privileges.categories.give([&#039;groups:topics:create&#039;, &#039;groups:topics:reply&#039;], cid, &#039;banned-users&#039;),
                privileges.categories.rescind([&#039;groups:topics:create&#039;, &#039;groups:topics:reply&#039;], cid, &#039;registered-users&#039;),
            ]);

            const result = await Topics.post({ title: &#039;banned topic&#039;, content: &#039;tttttttttttt&#039;, cid: cid, uid: testUid });
            assert(result);
            assert.strictEqual(result.topicData.title, &#039;banned topic&#039;);
        });
    });

    describe(&#039;Digest.getSubscribers&#039;, () =&gt; {
        const uidIndex = {};

        before((done) =&gt; {
            const testUsers = [&#039;daysub&#039;, &#039;offsub&#039;, &#039;nullsub&#039;, &#039;weeksub&#039;];
            async.each(testUsers, (username, next) =&gt; {
                async.waterfall([
                    async.apply(User.create, { username: username, email: `${username}@example.com` }),
                    function (uid, next) {
                        if (username === &#039;nullsub&#039;) {
                            return setImmediate(next);
                        }

                        uidIndex[username] = uid;

                        const sub = username.slice(0, -3);
                        async.parallel([
                            async.apply(User.updateDigestSetting, uid, sub),
                            async.apply(User.setSetting, uid, &#039;dailyDigestFreq&#039;, sub),
                        ], next);
                    },
                ], next);
            }, done);
        });

        it(&#039;should accurately build digest list given ACP default &quot;null&quot; (not set)&#039;, (done) =&gt; {
            User.digest.getSubscribers(&#039;day&#039;, (err, subs) =&gt; {
                assert.ifError(err);
                assert.strictEqual(subs.length, 1);

                done();
            });
        });

        it(&#039;should accurately build digest list given ACP default &quot;day&quot;&#039;, (done) =&gt; {
            async.series([
                async.apply(meta.configs.set, &#039;dailyDigestFreq&#039;, &#039;day&#039;),
                function (next) {
                    User.digest.getSubscribers(&#039;day&#039;, (err, subs) =&gt; {
                        assert.ifError(err);
                        assert.strictEqual(subs.includes(uidIndex.daysub.toString()), true); // daysub is emailed
                        assert.strictEqual(subs.includes(uidIndex.weeksub.toString()), false); // weeksub isn&#039;t emailed
                        assert.strictEqual(subs.includes(uidIndex.offsub.toString()), false); // offsub isn&#039;t emailed

                        next();
                    });
                },
            ], done);
        });

        it(&#039;should accurately build digest list given ACP default &quot;week&quot;&#039;, (done) =&gt; {
            async.series([
                async.apply(meta.configs.set, &#039;dailyDigestFreq&#039;, &#039;week&#039;),
                function (next) {
                    User.digest.getSubscribers(&#039;week&#039;, (err, subs) =&gt; {
                        assert.ifError(err);
                        assert.strictEqual(subs.includes(uidIndex.weeksub.toString()), true); // weeksub is emailed
                        assert.strictEqual(subs.includes(uidIndex.daysub.toString()), false); // daysub is emailed
                        assert.strictEqual(subs.includes(uidIndex.offsub.toString()), false); // offsub isn&#039;t emailed

                        next();
                    });
                },
            ], done);
        });

        it(&#039;should accurately build digest list given ACP default &quot;off&quot;&#039;, (done) =&gt; {
            async.series([
                async.apply(meta.configs.set, &#039;dailyDigestFreq&#039;, &#039;off&#039;),
                function (next) {
                    User.digest.getSubscribers(&#039;day&#039;, (err, subs) =&gt; {
                        assert.ifError(err);
                        assert.strictEqual(subs.length, 1);

                        next();
                    });
                },
            ], done);
        });
    });

    describe(&#039;digests&#039;, () =&gt; {
        let uid;
        before((done) =&gt; {
            async.waterfall([
                function (next) {
                    User.create({ username: &#039;digestuser&#039;, email: &#039;test@example.com&#039; }, next);
                },
                function (_uid, next) {
                    uid = _uid;
                    User.updateDigestSetting(uid, &#039;day&#039;, next);
                },
                function (next) {
                    User.setSetting(uid, &#039;dailyDigestFreq&#039;, &#039;day&#039;, next);
                },
                function (next) {
                    User.setSetting(uid, &#039;notificationType_test&#039;, &#039;notificationemail&#039;, next);
                },
            ], done);
        });

        it(&#039;should send digests&#039;, (done) =&gt; {
            const oldValue = meta.config.includeUnverifiedEmails;
            meta.config.includeUnverifiedEmails = true;
            User.digest.execute({ interval: &#039;day&#039; }, (err) =&gt; {
                assert.ifError(err);
                meta.config.includeUnverifiedEmails = oldValue;
                done();
            });
        });

        it(&#039;should not send digests&#039;, (done) =&gt; {
            User.digest.execute({ interval: &#039;month&#039; }, (err) =&gt; {
                assert.ifError(err);
                done();
            });
        });

        it(&#039;should get delivery times&#039;, async () =&gt; {
            const data = await User.digest.getDeliveryTimes(0, -1);
            const users = data.users.filter(u =&gt; u.username === &#039;digestuser&#039;);
            assert.strictEqual(users[0].setting, &#039;day&#039;);
        });

        describe(&#039;unsubscribe via POST&#039;, () =&gt; {
            it(&#039;should unsubscribe from digest if one-click unsubscribe is POSTed&#039;, (done) =&gt; {
                const token = jwt.sign({
                    template: &#039;digest&#039;,
                    uid: uid,
                }, nconf.get(&#039;secret&#039;));

                request({
                    method: &#039;post&#039;,
                    url: `${nconf.get(&#039;url&#039;)}/email/unsubscribe/${token}`,
                }, (err, res) =&gt; {
                    assert.ifError(err);
                    assert.strictEqual(res.statusCode, 200);

                    db.getObjectField(`user:${uid}:settings`, &#039;dailyDigestFreq&#039;, (err, value) =&gt; {
                        assert.ifError(err);
                        assert.strictEqual(value, &#039;off&#039;);
                        done();
                    });
                });
            });

            it(&#039;should unsubscribe from notifications if one-click unsubscribe is POSTed&#039;, (done) =&gt; {
                const token = jwt.sign({
                    template: &#039;notification&#039;,
                    type: &#039;test&#039;,
                    uid: uid,
                }, nconf.get(&#039;secret&#039;));

                request({
                    method: &#039;post&#039;,
                    url: `${nconf.get(&#039;url&#039;)}/email/unsubscribe/${token}`,
                }, (err, res) =&gt; {
                    assert.ifError(err);
                    assert.strictEqual(res.statusCode, 200);

                    db.getObjectField(`user:${uid}:settings`, &#039;notificationType_test&#039;, (err, value) =&gt; {
                        assert.ifError(err);
                        assert.strictEqual(value, &#039;notification&#039;);
                        done();
                    });
                });
            });

            it(&#039;should return errors on missing template in token&#039;, (done) =&gt; {
                const token = jwt.sign({
                    uid: uid,
                }, nconf.get(&#039;secret&#039;));

                request({
                    method: &#039;post&#039;,
                    url: `${nconf.get(&#039;url&#039;)}/email/unsubscribe/${token}`,
                }, (err, res) =&gt; {
                    assert.ifError(err);
                    assert.strictEqual(res.statusCode, 404);
                    done();
                });
            });

            it(&#039;should return errors on wrong template in token&#039;, (done) =&gt; {
                const token = jwt.sign({
                    template: &#039;user&#039;,
                    uid: uid,
                }, nconf.get(&#039;secret&#039;));

                request({
                    method: &#039;post&#039;,
                    url: `${nconf.get(&#039;url&#039;)}/email/unsubscribe/${token}`,
                }, (err, res) =&gt; {
                    assert.ifError(err);
                    assert.strictEqual(res.statusCode, 404);
                    done();
                });
            });

            it(&#039;should return errors on missing token&#039;, (done) =&gt; {
                request({
                    method: &#039;post&#039;,
                    url: `${nconf.get(&#039;url&#039;)}/email/unsubscribe/`,
                }, (err, res) =&gt; {
                    assert.ifError(err);
                    assert.strictEqual(res.statusCode, 404);
                    done();
                });
            });

            it(&#039;should return errors on token signed with wrong secret (verify-failure)&#039;, (done) =&gt; {
                const token = jwt.sign({
                    template: &#039;notification&#039;,
                    type: &#039;test&#039;,
                    uid: uid,
                }, `${nconf.get(&#039;secret&#039;)}aababacaba`);

                request({
                    method: &#039;post&#039;,
                    url: `${nconf.get(&#039;url&#039;)}/email/unsubscribe/${token}`,
                }, (err, res) =&gt; {
                    assert.ifError(err);
                    assert.strictEqual(res.statusCode, 403);
                    done();
                });
            });
        });
    });

    describe(&#039;socket methods&#039;, () =&gt; {
        const socketUser = require(&#039;../src/socket.io/user&#039;);
        let delUid;

        it(&#039;should fail with invalid data&#039;, (done) =&gt; {
            meta.userOrGroupExists(null, (err) =&gt; {
                assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
                done();
            });
        });

        it(&#039;should return true if user/group exists&#039;, (done) =&gt; {
            meta.userOrGroupExists(&#039;registered-users&#039;, (err, exists) =&gt; {
                assert.ifError(err);
                assert(exists);
                done();
            });
        });

        it(&#039;should return true if user/group exists&#039;, (done) =&gt; {
            meta.userOrGroupExists(&#039;John Smith&#039;, (err, exists) =&gt; {
                assert.ifError(err);
                assert(exists);
                done();
            });
        });

        it(&#039;should return false if user/group does not exists&#039;, (done) =&gt; {
            meta.userOrGroupExists(&#039;doesnot exist&#039;, (err, exists) =&gt; {
                assert.ifError(err);
                assert(!exists);
                done();
            });
        });

        it(&#039;should delete user&#039;, async () =&gt; {
            delUid = await User.create({ username: &#039;willbedeleted&#039; });

            // Upload some avatars and covers before deleting
            meta.config[&#039;profile:keepAllUserImages&#039;] = 1;
            let result = await socketUser.uploadCroppedPicture({ uid: delUid }, { uid: delUid, imageData: goodImage });
            assert(result.url);
            result = await socketUser.uploadCroppedPicture({ uid: delUid }, { uid: delUid, imageData: goodImage });
            assert(result.url);

            const position = &#039;50.0301% 19.2464%&#039;;
            const coverData = { uid: delUid, imageData: goodImage, position: position };
            result = await socketUser.updateCover({ uid: delUid }, coverData);
            assert(result.url);
            result = await socketUser.updateCover({ uid: delUid }, coverData);
            assert(result.url);
            meta.config[&#039;profile:keepAllUserImages&#039;] = 0;

            await apiUser.deleteAccount({ uid: delUid }, { uid: delUid });
            const exists = await meta.userOrGroupExists(&#039;willbedeleted&#039;);
            assert(!exists);
        });

        it(&#039;should clean profile images after account deletion&#039;, () =&gt; {
            const allProfileFiles = fs.readdirSync(path.join(nconf.get(&#039;upload_path&#039;), &#039;profile&#039;));
            const deletedUserImages = allProfileFiles.filter(
                f =&gt; f.startsWith(`${delUid}-profilecover`) || f.startsWith(`${delUid}-profileavatar`)
            );
            assert.strictEqual(deletedUserImages.length, 0);
        });

        it(&#039;should fail to delete user with wrong password&#039;, async () =&gt; {
            const uid = await User.create({ username: &#039;willbedeletedpwd&#039;, password: &#039;123456&#039; });
            try {
                await apiUser.deleteAccount({ uid: uid }, { uid: uid, password: &#039;654321&#039; });
                assert(false);
            } catch (err) {
                assert.strictEqual(err.message, &#039;[[error:invalid-password]]&#039;);
            }
        });

        it(&#039;should delete user with correct password&#039;, async () =&gt; {
            const uid = await User.create({ username: &#039;willbedeletedcorrectpwd&#039;, password: &#039;123456&#039; });
            await apiUser.deleteAccount({ uid: uid }, { uid: uid, password: &#039;123456&#039; });
            const exists = await User.exists(uid);
            assert(!exists);
        });

        it(&#039;should fail to delete user if account deletion is not allowed&#039;, async () =&gt; {
            const oldValue = meta.config.allowAccountDelete;
            meta.config.allowAccountDelete = 0;
            const uid = await User.create({ username: &#039;tobedeleted&#039; });
            try {
                await apiUser.deleteAccount({ uid: uid }, { uid: uid });
                assert(false);
            } catch (err) {
                assert.strictEqual(err.message, &#039;[[error:account-deletion-disabled]]&#039;);
            }
            meta.config.allowAccountDelete = oldValue;
        });

        it(&#039;should send reset email&#039;, (done) =&gt; {
            socketUser.reset.send({ uid: 0 }, &#039;john@example.com&#039;, (err) =&gt; {
                assert.ifError(err);
                done();
            });
        });

        it(&#039;should return invalid-data error&#039;, (done) =&gt; {
            socketUser.reset.send({ uid: 0 }, null, (err) =&gt; {
                assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
                done();
            });
        });

        it(&#039;should not error&#039;, (done) =&gt; {
            socketUser.reset.send({ uid: 0 }, &#039;doestnot@exist.com&#039;, (err) =&gt; {
                assert.ifError(err);
                done();
            });
        });

        it(&#039;should commit reset&#039;, (done) =&gt; {
            db.getObject(&#039;reset:uid&#039;, (err, data) =&gt; {
                assert.ifError(err);
                const code = Object.keys(data).find(code =&gt; parseInt(data[code], 10) === parseInt(testUid, 10));
                socketUser.reset.commit({ uid: 0 }, { code: code, password: &#039;pwdchange&#039; }, (err) =&gt; {
                    assert.ifError(err);
                    done();
                });
            });
        });

        it(&#039;should save user settings&#039;, async () =&gt; {
            const data = {
                uid: testUid,
                settings: {
                    bootswatchSkin: &#039;default&#039;,
                    homePageRoute: &#039;none&#039;,
                    homePageCustom: &#039;&#039;,
                    openOutgoingLinksInNewTab: 0,
                    scrollToMyPost: 1,
                    userLang: &#039;en-GB&#039;,
                    usePagination: 1,
                    topicsPerPage: &#039;10&#039;,
                    postsPerPage: &#039;5&#039;,
                    showemail: 1,
                    showfullname: 1,
                    restrictChat: 0,
                    followTopicsOnCreate: 1,
                    followTopicsOnReply: 1,
                },
            };
            await apiUser.updateSettings({ uid: testUid }, data);
            const userSettings = await User.getSettings(testUid);
            assert.strictEqual(userSettings.usePagination, true);
        });

        it(&#039;should properly escape homePageRoute&#039;, async () =&gt; {
            const data = {
                uid: testUid,
                settings: {
                    bootswatchSkin: &#039;default&#039;,
                    homePageRoute: &#039;category/6/testing-ground&#039;,
                    homePageCustom: &#039;&#039;,
                    openOutgoingLinksInNewTab: 0,
                    scrollToMyPost: 1,
                    userLang: &#039;en-GB&#039;,
                    usePagination: 1,
                    topicsPerPage: &#039;10&#039;,
                    postsPerPage: &#039;5&#039;,
                    showemail: 1,
                    showfullname: 1,
                    restrictChat: 0,
                    followTopicsOnCreate: 1,
                    followTopicsOnReply: 1,
                },
            };
            await apiUser.updateSettings({ uid: testUid }, data);
            const userSettings = await User.getSettings(testUid);
            assert.strictEqual(userSettings.homePageRoute, &#039;category/6/testing-ground&#039;);
        });


        it(&#039;should error if language is invalid&#039;, async () =&gt; {
            const data = {
                uid: testUid,
                settings: {
                    userLang: &#039;&lt;invalid-string&gt;&#039;,
                    topicsPerPage: &#039;10&#039;,
                    postsPerPage: &#039;5&#039;,
                },
            };
            try {
                await apiUser.updateSettings({ uid: testUid }, data);
                assert(false);
            } catch (err) {
                assert.equal(err.message, &#039;[[error:invalid-language]]&#039;);
            }
        });

        it(&#039;should set moderation note&#039;, (done) =&gt; {
            let adminUid;
            async.waterfall([
                function (next) {
                    User.create({ username: &#039;noteadmin&#039; }, next);
                },
                function (_adminUid, next) {
                    adminUid = _adminUid;
                    groups.join(&#039;administrators&#039;, adminUid, next);
                },
                function (next) {
                    socketUser.setModerationNote({ uid: adminUid }, { uid: testUid, note: &#039;this is a test user&#039; }, next);
                },
                function (next) {
                    setTimeout(next, 50);
                },
                function (next) {
                    socketUser.setModerationNote({ uid: adminUid }, { uid: testUid, note: &#039;&lt;svg/onload=alert(document.location);//&#039; }, next);
                },
                function (next) {
                    User.getModerationNotes(testUid, 0, -1, next);
                },
            ], (err, notes) =&gt; {
                assert.ifError(err);
                assert.equal(notes[0].note, &#039;&amp;lt;svg&amp;#x2F;onload=alert(document.location);&amp;#x2F;&amp;#x2F;&#039;);
                assert.equal(notes[0].uid, adminUid);
                assert.equal(notes[1].note, &#039;this is a test user&#039;);
                assert(notes[0].timestamp);
                done();
            });
        });

        it(&#039;should get unread count 0 for guest&#039;, async () =&gt; {
            const count = await socketUser.getUnreadCount({ uid: 0 });
            assert.strictEqual(count, 0);
        });

        it(&#039;should get unread count for user&#039;, async () =&gt; {
            const count = await socketUser.getUnreadCount({ uid: testUid });
            assert.strictEqual(count, 4);
        });

        it(&#039;should get unread chat count 0 for guest&#039;, async () =&gt; {
            const count = await socketUser.getUnreadChatCount({ uid: 0 });
            assert.strictEqual(count, 0);
        });

        it(&#039;should get unread chat count for user&#039;, async () =&gt; {
            const count = await socketUser.getUnreadChatCount({ uid: testUid });
            assert.strictEqual(count, 0);
        });

        it(&#039;should get unread counts 0 for guest&#039;, async () =&gt; {
            const counts = await socketUser.getUnreadCounts({ uid: 0 });
            assert.deepStrictEqual(counts, {});
        });

        it(&#039;should get unread counts for user&#039;, async () =&gt; {
            const counts = await socketUser.getUnreadCounts({ uid: testUid });
            assert.deepStrictEqual(counts, {
                unreadChatCount: 0,
                unreadCounts: {
                    &#039;&#039;: 4,
                    new: 4,
                    unreplied: 4,
                    watched: 0,
                },
                unreadNewTopicCount: 4,
                unreadNotificationCount: 0,
                unreadTopicCount: 4,
                unreadUnrepliedTopicCount: 4,
                unreadWatchedTopicCount: 0,
            });
        });

        it(&#039;should get user data by uid&#039;, async () =&gt; {
            const userData = await socketUser.getUserByUID({ uid: testUid }, testUid);
            assert.strictEqual(userData.uid, testUid);
        });

        it(&#039;should get user data by username&#039;, async () =&gt; {
            const userData = await socketUser.getUserByUsername({ uid: testUid }, &#039;John Smith&#039;);
            assert.strictEqual(userData.uid, testUid);
        });

        it(&#039;should get user data by email&#039;, async () =&gt; {
            const userData = await socketUser.getUserByEmail({ uid: testUid }, &#039;john@example.com&#039;);
            assert.strictEqual(userData.uid, testUid);
        });

        it(&#039;should check/consent gdpr status&#039;, async () =&gt; {
            const consent = await socketUser.gdpr.check({ uid: testUid }, { uid: testUid });
            assert(!consent);
            await socketUser.gdpr.consent({ uid: testUid });
            const consentAfter = await socketUser.gdpr.check({ uid: testUid }, { uid: testUid });
            assert(consentAfter);
        });
    });

    describe(&#039;approval queue&#039;, () =&gt; {
        let oldRegistrationApprovalType;
        let adminUid;
        before((done) =&gt; {
            oldRegistrationApprovalType = meta.config.registrationApprovalType;
            meta.config.registrationApprovalType = &#039;admin-approval&#039;;
            User.create({ username: &#039;admin&#039;, password: &#039;123456&#039; }, (err, uid) =&gt; {
                assert.ifError(err);
                adminUid = uid;
                groups.join(&#039;administrators&#039;, uid, done);
            });
        });

        after((done) =&gt; {
            meta.config.registrationApprovalType = oldRegistrationApprovalType;
            done();
        });

        it(&#039;should add user to approval queue&#039;, (done) =&gt; {
            helpers.registerUser({
                username: &#039;rejectme&#039;,
                password: &#039;123456&#039;,
                &#039;password-confirm&#039;: &#039;123456&#039;,
                &#039;account-type&#039;: &#039;student&#039;,
                email: &#039;&lt;script&gt;alert(&quot;ok&quot;)&lt;script&gt;reject@me.com&#039;,
                gdpr_consent: true,
            }, (err) =&gt; {
                assert.ifError(err);
                helpers.loginUser(&#039;admin&#039;, &#039;123456&#039;, (err, data) =&gt; {
                    assert.ifError(err);
                    request(`${nconf.get(&#039;url&#039;)}/api/admin/manage/registration`, { jar: data.jar, json: true }, (err, res, body) =&gt; {
                        assert.ifError(err);
                        assert.equal(body.users[0].username, &#039;rejectme&#039;);
                        assert.equal(body.users[0].email, &#039;&amp;lt;script&amp;gt;alert(&amp;quot;ok&amp;quot;)&amp;lt;script&amp;gt;reject@me.com&#039;);
                        done();
                    });
                });
            });
        });

        it(&#039;should fail to add user to queue if username is taken&#039;, (done) =&gt; {
            helpers.registerUser({
                username: &#039;rejectme&#039;,
                password: &#039;123456&#039;,
                &#039;password-confirm&#039;: &#039;123456&#039;,
                &#039;account-type&#039;: &#039;student&#039;,
                email: &#039;&lt;script&gt;alert(&quot;ok&quot;)&lt;script&gt;reject@me.com&#039;,
                gdpr_consent: true,
            }, (err, jar, res, body) =&gt; {
                assert.ifError(err);
                assert.equal(body, &#039;[[error:username-taken]]&#039;);
                done();
            });
        });

        it(&#039;should fail to add user to queue if email is taken&#039;, (done) =&gt; {
            helpers.registerUser({
                username: &#039;rejectmenew&#039;,
                password: &#039;123456&#039;,
                &#039;password-confirm&#039;: &#039;123456&#039;,
                &#039;account-type&#039;: &#039;student&#039;,
                email: &#039;&lt;script&gt;alert(&quot;ok&quot;)&lt;script&gt;reject@me.com&#039;,
                gdpr_consent: true,
            }, (err, jar, res, body) =&gt; {
                assert.ifError(err);
                assert.equal(body, &#039;[[error:email-taken]]&#039;);
                done();
            });
        });

        it(&#039;should reject user registration&#039;, (done) =&gt; {
            socketUser.rejectRegistration({ uid: adminUid }, { username: &#039;rejectme&#039; }, (err) =&gt; {
                assert.ifError(err);
                User.getRegistrationQueue(0, -1, (err, users) =&gt; {
                    assert.ifError(err);
                    assert.equal(users.length, 0);
                    done();
                });
            });
        });

        it(&#039;should accept user registration&#039;, (done) =&gt; {
            helpers.registerUser({
                username: &#039;acceptme&#039;,
                password: &#039;123456&#039;,
                &#039;password-confirm&#039;: &#039;123456&#039;,
                &#039;account-type&#039;: &#039;student&#039;,
                email: &#039;accept@me.com&#039;,
                gdpr_consent: true,
            }, (err) =&gt; {
                assert.ifError(err);
                socketUser.acceptRegistration({ uid: adminUid }, { username: &#039;acceptme&#039; }, (err, uid) =&gt; {
                    assert.ifError(err);
                    User.exists(uid, (err, exists) =&gt; {
                        assert.ifError(err);
                        assert(exists);
                        User.getRegistrationQueue(0, -1, (err, users) =&gt; {
                            assert.ifError(err);
                            assert.equal(users.length, 0);
                            done();
                        });
                    });
                });
            });
        });

        it(&#039;should trim username and add user to registration queue&#039;, (done) =&gt; {
            helpers.registerUser({
                username: &#039;invalidname\r\n&#039;,
                password: &#039;123456&#039;,
                &#039;password-confirm&#039;: &#039;123456&#039;,
                &#039;account-type&#039;: &#039;student&#039;,
                email: &#039;invalidtest@test.com&#039;,
                gdpr_consent: true,
            }, (err) =&gt; {
                assert.ifError(err);
                db.getSortedSetRange(&#039;registration:queue&#039;, 0, -1, (err, data) =&gt; {
                    assert.ifError(err);
                    assert.equal(data[0], &#039;invalidname&#039;);
                    done();
                });
            });
        });
    });

    describe(&#039;invites&#039;, () =&gt; {
        let notAnInviterUid;
        let inviterUid;
        let adminUid;

        const PUBLIC_GROUP = &#039;publicGroup&#039;;
        const PRIVATE_GROUP = &#039;privateGroup&#039;;
        const OWN_PRIVATE_GROUP = &#039;ownPrivateGroup&#039;;
        const HIDDEN_GROUP = &#039;hiddenGroup&#039;;

        const COMMON_PW = &#039;123456&#039;;

        before(async () =&gt; {
            const results = await utils.promiseParallel({
                publicGroup: groups.create({ name: PUBLIC_GROUP, private: 0 }),
                privateGroup: groups.create({ name: PRIVATE_GROUP, private: 1 }),
                hiddenGroup: groups.create({ name: HIDDEN_GROUP, hidden: 1 }),
                notAnInviter: User.create({ username: &#039;notAnInviter&#039;, password: COMMON_PW }),
                inviter: User.create({ username: &#039;inviter&#039;, password: COMMON_PW }),
                admin: User.create({ username: &#039;adminInvite&#039;, password: COMMON_PW }),
            });

            notAnInviterUid = results.notAnInviter;
            inviterUid = results.inviter;
            adminUid = results.admin;

            await User.setUserField(inviterUid, &#039;email&#039;, &#039;inviter@nodebb.org&#039;);
            await Promise.all([
                groups.create({ name: OWN_PRIVATE_GROUP, ownerUid: inviterUid, private: 1 }),
                groups.join(&#039;administrators&#039;, adminUid),
                groups.join(&#039;cid:0:privileges:invite&#039;, inviterUid),
                User.email.confirmByUid(inviterUid),
            ]);
        });

        describe(&#039;when inviter is not an admin and does not have invite privilege&#039;, () =&gt; {
            let csrf_token;
            let jar;

            before((done) =&gt; {
                helpers.loginUser(&#039;notAnInviter&#039;, COMMON_PW, (err, data) =&gt; {
                    assert.ifError(err);
                    jar = data.jar;

                    request({
                        url: `${nconf.get(&#039;url&#039;)}/api/config`,
                        json: true,
                        jar: jar,
                    }, (err, response, body) =&gt; {
                        assert.ifError(err);
                        csrf_token = body.csrf_token;
                        done();
                    });
                });
            });

            it(&#039;should error if user does not have invite privilege&#039;, async () =&gt; {
                const { res } = await helpers.invite({ emails: &#039;invite1@test.com&#039;, groupsToJoin: [] }, notAnInviterUid, jar, csrf_token);
                assert.strictEqual(res.statusCode, 403);
                assert.strictEqual(res.body.status.message, &#039;You do not have enough privileges for this action.&#039;);
            });

            it(&#039;should error out if user tries to use an inviter\&#039;s uid via the API&#039;, async () =&gt; {
                const { res } = await helpers.invite({ emails: &#039;invite1@test.com&#039;, groupsToJoin: [] }, inviterUid, jar, csrf_token);
                const numInvites = await User.getInvitesNumber(inviterUid);
                assert.strictEqual(res.statusCode, 403);
                assert.strictEqual(res.body.status.message, &#039;You do not have enough privileges for this action.&#039;);
                assert.strictEqual(numInvites, 0);
            });
        });

        describe(&#039;when inviter has invite privilege&#039;, () =&gt; {
            let csrf_token;
            let jar;

            before((done) =&gt; {
                helpers.loginUser(&#039;inviter&#039;, COMMON_PW, (err, data) =&gt; {
                    assert.ifError(err);
                    jar = data.jar;

                    request({
                        url: `${nconf.get(&#039;url&#039;)}/api/config`,
                        json: true,
                        jar: jar,
                    }, (err, response, body) =&gt; {
                        assert.ifError(err);
                        csrf_token = body.csrf_token;
                        done();
                    });
                });
            });

            it(&#039;should error with invalid data&#039;, async () =&gt; {
                const { res } = await helpers.invite({}, inviterUid, jar, csrf_token);
                assert.strictEqual(res.statusCode, 400);
                assert.strictEqual(res.body.status.message, &#039;Invalid Data&#039;);
            });

            it(&#039;should error if user is not admin and type is admin-invite-only&#039;, async () =&gt; {
                meta.config.registrationType = &#039;admin-invite-only&#039;;
                const { res } = await helpers.invite({ emails: &#039;invite1@test.com&#039;, groupsToJoin: [] }, inviterUid, jar, csrf_token);
                assert.strictEqual(res.statusCode, 403);
                assert.strictEqual(res.body.status.message, &#039;You do not have enough privileges for this action.&#039;);
            });

            it(&#039;should send invitation email (without groups to be joined)&#039;, async () =&gt; {
                meta.config.registrationType = &#039;normal&#039;;
                const { res } = await helpers.invite({ emails: &#039;invite1@test.com&#039;, groupsToJoin: [] }, inviterUid, jar, csrf_token);
                assert.strictEqual(res.statusCode, 200);
            });

            it(&#039;should send multiple invitation emails (with a public group to be joined)&#039;, async () =&gt; {
                const { res } = await helpers.invite({ emails: &#039;invite2@test.com,invite3@test.com&#039;, groupsToJoin: [PUBLIC_GROUP] }, inviterUid, jar, csrf_token);
                assert.strictEqual(res.statusCode, 200);
            });

            it(&#039;should error if the user has not permission to invite to the group&#039;, async () =&gt; {
                const { res } = await helpers.invite({ emails: &#039;invite4@test.com&#039;, groupsToJoin: [PRIVATE_GROUP] }, inviterUid, jar, csrf_token);
                assert.strictEqual(res.statusCode, 403);
                assert.strictEqual(res.body.status.message, &#039;You do not have enough privileges for this action.&#039;);
            });

            it(&#039;should error if a non-admin tries to invite to the administrators group&#039;, async () =&gt; {
                const { res } = await helpers.invite({ emails: &#039;invite4@test.com&#039;, groupsToJoin: [&#039;administrators&#039;] }, inviterUid, jar, csrf_token);
                assert.strictEqual(res.statusCode, 403);
                assert.strictEqual(res.body.status.message, &#039;You do not have enough privileges for this action.&#039;);
            });

            it(&#039;should to invite to own private group&#039;, async () =&gt; {
                const { res } = await helpers.invite({ emails: &#039;invite4@test.com&#039;, groupsToJoin: [OWN_PRIVATE_GROUP] }, inviterUid, jar, csrf_token);
                assert.strictEqual(res.statusCode, 200);
            });

            it(&#039;should to invite to multiple groups&#039;, async () =&gt; {
                const { res } = await helpers.invite({ emails: &#039;invite5@test.com&#039;, groupsToJoin: [PUBLIC_GROUP, OWN_PRIVATE_GROUP] }, inviterUid, jar, csrf_token);
                assert.strictEqual(res.statusCode, 200);
            });

            it(&#039;should error if tries to invite to hidden group&#039;, async () =&gt; {
                const { res } = await helpers.invite({ emails: &#039;invite6@test.com&#039;, groupsToJoin: [HIDDEN_GROUP] }, inviterUid, jar, csrf_token);
                assert.strictEqual(res.statusCode, 403);
            });

            it(&#039;should error if ouf of invitations&#039;, async () =&gt; {
                meta.config.maximumInvites = 1;
                const { res } = await helpers.invite({ emails: &#039;invite6@test.com&#039;, groupsToJoin: [] }, inviterUid, jar, csrf_token);
                assert.strictEqual(res.statusCode, 403);
                assert.strictEqual(res.body.status.message, `You have invited the maximum amount of people (${5} out of ${1}).`);
                meta.config.maximumInvites = 10;
            });

            it(&#039;should send invitation email after maximumInvites increased&#039;, async () =&gt; {
                const { res } = await helpers.invite({ emails: &#039;invite6@test.com&#039;, groupsToJoin: [] }, inviterUid, jar, csrf_token);
                assert.strictEqual(res.statusCode, 200);
            });

            it(&#039;should error if invite is sent via API with a different UID&#039;, async () =&gt; {
                const { res } = await helpers.invite({ emails: &#039;inviter@nodebb.org&#039;, groupsToJoin: [] }, adminUid, jar, csrf_token);
                const numInvites = await User.getInvitesNumber(adminUid);
                assert.strictEqual(res.statusCode, 403);
                assert.strictEqual(res.body.status.message, &#039;You do not have enough privileges for this action.&#039;);
                assert.strictEqual(numInvites, 0);
            });

            it(&#039;should succeed if email exists but not actually send an invite&#039;, async () =&gt; {
                const { res } = await helpers.invite({ emails: &#039;inviter@nodebb.org&#039;, groupsToJoin: [] }, inviterUid, jar, csrf_token);
                const numInvites = await User.getInvitesNumber(adminUid);

                assert.strictEqual(res.statusCode, 200);
                assert.strictEqual(numInvites, 0);
            });
        });

        describe(&#039;when inviter is an admin&#039;, () =&gt; {
            let csrf_token;
            let jar;

            before((done) =&gt; {
                helpers.loginUser(&#039;adminInvite&#039;, COMMON_PW, (err, data) =&gt; {
                    assert.ifError(err);
                    jar = data.jar;

                    request({
                        url: `${nconf.get(&#039;url&#039;)}/api/config`,
                        json: true,
                        jar: jar,
                    }, (err, response, body) =&gt; {
                        assert.ifError(err);
                        csrf_token = body.csrf_token;
                        done();
                    });
                });
            });

            it(&#039;should escape email&#039;, async () =&gt; {
                await helpers.invite({ emails: &#039;&lt;script&gt;alert(&quot;ok&quot;);&lt;/script&gt;&#039;, groupsToJoin: [] }, adminUid, jar, csrf_token);
                const data = await User.getInvites(adminUid);
                assert.strictEqual(data[0], &#039;&amp;lt;script&amp;gt;alert(&amp;quot;ok&amp;quot;);&amp;lt;&amp;#x2F;script&amp;gt;&#039;);
                await User.deleteInvitationKey(&#039;&lt;script&gt;alert(&quot;ok&quot;);&lt;/script&gt;&#039;);
            });

            it(&#039;should invite to the administrators group if inviter is an admin&#039;, async () =&gt; {
                const { res } = await helpers.invite({ emails: &#039;invite99@test.com&#039;, groupsToJoin: [&#039;administrators&#039;] }, adminUid, jar, csrf_token);
                assert.strictEqual(res.statusCode, 200);
            });
        });

        describe(&#039;after invites checks&#039;, () =&gt; {
            it(&#039;should get user\&#039;s invites&#039;, (done) =&gt; {
                User.getInvites(inviterUid, (err, data) =&gt; {
                    assert.ifError(err);
                    Array.from(Array(6)).forEach((_, i) =&gt; {
                        assert.notEqual(data.indexOf(`invite${i + 1}@test.com`), -1);
                    });
                    done();
                });
            });

            it(&#039;should get all invites&#039;, (done) =&gt; {
                User.getAllInvites((err, data) =&gt; {
                    assert.ifError(err);

                    const adminData = data.filter(d =&gt; parseInt(d.uid, 10) === adminUid)[0];
                    assert.notEqual(adminData.invitations.indexOf(&#039;invite99@test.com&#039;), -1);

                    const inviterData = data.filter(d =&gt; parseInt(d.uid, 10) === inviterUid)[0];
                    Array.from(Array(6)).forEach((_, i) =&gt; {
                        assert.notEqual(inviterData.invitations.indexOf(`invite${i + 1}@test.com`), -1);
                    });

                    done();
                });
            });

            it(&#039;should fail to verify invitation with invalid data&#039;, (done) =&gt; {
                User.verifyInvitation({ token: &#039;&#039;, email: &#039;&#039; }, (err) =&gt; {
                    assert.strictEqual(err.message, &#039;[[register:invite.error-invite-only]]&#039;);
                    done();
                });
            });

            it(&#039;should fail to verify invitation with invalid email&#039;, (done) =&gt; {
                User.verifyInvitation({ token: &#039;test&#039;, email: &#039;doesnotexist@test.com&#039; }, (err) =&gt; {
                    assert.strictEqual(err.message, &#039;[[register:invite.error-invalid-data]]&#039;);
                    done();
                });
            });

            it(&#039;should verify installation with no errors&#039;, (done) =&gt; {
                const email = &#039;invite1@test.com&#039;;
                db.get(`invitation:uid:${inviterUid}:invited:${email}`, &#039;token&#039;, (err, token) =&gt; {
                    assert.ifError(err);
                    User.verifyInvitation({ token: token, email: &#039;invite1@test.com&#039; }, (err) =&gt; {
                        assert.ifError(err);
                        done();
                    });
                });
            });

            it(&#039;should error with invalid username&#039;, (done) =&gt; {
                User.deleteInvitation(&#039;doesnotexist&#039;, &#039;test@test.com&#039;, (err) =&gt; {
                    assert.equal(err.message, &#039;[[error:invalid-username]]&#039;);
                    done();
                });
            });

            it(&#039;should delete invitation&#039;, (done) =&gt; {
                const socketUser = require(&#039;../src/socket.io/user&#039;);
                socketUser.deleteInvitation({ uid: adminUid }, { invitedBy: &#039;inviter&#039;, email: &#039;invite1@test.com&#039; }, (err) =&gt; {
                    assert.ifError(err);
                    db.isSetMember(`invitation:uid:${inviterUid}`, &#039;invite1@test.com&#039;, (err, isMember) =&gt; {
                        assert.ifError(err);
                        assert.equal(isMember, false);
                        done();
                    });
                });
            });

            it(&#039;should delete invitation key&#039;, (done) =&gt; {
                User.deleteInvitationKey(&#039;invite99@test.com&#039;, (err) =&gt; {
                    assert.ifError(err);
                    db.isSetMember(`invitation:uid:${adminUid}`, &#039;invite99@test.com&#039;, (err, isMember) =&gt; {
                        assert.ifError(err);
                        assert.equal(isMember, false);
                        db.isSetMember(&#039;invitation:uids&#039;, adminUid, (err, isMember) =&gt; {
                            assert.ifError(err);
                            assert.equal(isMember, false);
                            done();
                        });
                    });
                });
            });

            it(&#039;should joined the groups from invitation after registration&#039;, async () =&gt; {
                const email = &#039;invite5@test.com&#039;;
                const groupsToJoin = [PUBLIC_GROUP, OWN_PRIVATE_GROUP];
                const token = await db.get(`invitation:uid:${inviterUid}:invited:${email}`);

                await new Promise((resolve, reject) =&gt; {
                    helpers.registerUser({
                        username: &#039;invite5&#039;,
                        password: &#039;123456&#039;,
                        &#039;password-confirm&#039;: &#039;123456&#039;,
                        &#039;account-type&#039;: &#039;student&#039;,
                        email: email,
                        gdpr_consent: true,
                        token: token,
                    }, async (err, jar, response, body) =&gt; {
                        if (err) {
                            reject(err);
                        }

                        const memberships = await groups.isMemberOfGroups(body.uid, groupsToJoin);
                        const joinedToAll = memberships.filter(Boolean);

                        if (joinedToAll.length !== groupsToJoin.length) {
                            reject(new Error(&#039;Not joined to the groups&#039;));
                        }

                        resolve();
                    });
                });
            });
        });

        describe(&#039;invite groups&#039;, () =&gt; {
            let csrf_token;
            let jar;

            before((done) =&gt; {
                helpers.loginUser(&#039;inviter&#039;, COMMON_PW, (err, data) =&gt; {
                    assert.ifError(err);
                    jar = data.jar;

                    request({
                        url: `${nconf.get(&#039;url&#039;)}/api/config`,
                        json: true,
                        jar: jar,
                    }, (err, response, body) =&gt; {
                        assert.ifError(err);
                        csrf_token = body.csrf_token;
                        done();
                    });
                });
            });

            it(&#039;should show a list of groups for adding to an invite&#039;, async () =&gt; {
                const body = await requestAsync({
                    url: `${nconf.get(&#039;url&#039;)}/api/v3/users/${inviterUid}/invites/groups`,
                    json: true,
                    jar,
                });

                assert(Array.isArray(body.response));
                assert.strictEqual(2, body.response.length);
                assert.deepStrictEqual(body.response, [&#039;ownPrivateGroup&#039;, &#039;publicGroup&#039;]);
            });

            it(&#039;should error out if you request invite groups for another uid&#039;, async () =&gt; {
                const res = await requestAsync({
                    url: `${nconf.get(&#039;url&#039;)}/api/v3/users/${adminUid}/invites/groups`,
                    json: true,
                    jar,
                    simple: false,
                    resolveWithFullResponse: true,
                });

                assert.strictEqual(res.statusCode, 401);
                assert.deepStrictEqual(res.body, {
                    status: {
                        code: &#039;not-authorised&#039;,
                        message: &#039;A valid login session was not found. Please log in and try again.&#039;,
                    },
                    response: {},
                });
            });
        });
    });

    describe(&#039;email confirm&#039;, () =&gt; {
        it(&#039;should error with invalid code&#039;, (done) =&gt; {
            User.email.confirmByCode(&#039;asdasda&#039;, (err) =&gt; {
                assert.equal(err.message, &#039;[[error:invalid-data]]&#039;);
                done();
            });
        });

        it(&#039;should confirm email of user&#039;, async () =&gt; {
            const email = &#039;confirm@me.com&#039;;
            const uid = await User.create({
                username: &#039;confirme&#039;,
                email: email,
            });

            const code = await User.email.sendValidationEmail(uid, { email, force: 1 });
            const unverified = await groups.isMember(uid, &#039;unverified-users&#039;);
            assert.strictEqual(unverified, true);
            await User.email.confirmByCode(code);
            const [confirmed, isVerified] = await Promise.all([
                db.getObjectField(`user:${uid}`, &#039;email:confirmed&#039;),
                groups.isMember(uid, &#039;verified-users&#039;, uid),
            ]);
            assert.strictEqual(parseInt(confirmed, 10), 1);
            assert.strictEqual(isVerified, true);
        });

        it(&#039;should confirm email of user by uid&#039;, async () =&gt; {
            const email = &#039;confirm2@me.com&#039;;
            const uid = await User.create({
                username: &#039;confirme2&#039;,
                email,
            });
            await User.setUserField(uid, &#039;email&#039;, email);

            const unverified = await groups.isMember(uid, &#039;unverified-users&#039;);
            assert.strictEqual(unverified, true);
            await User.email.confirmByUid(uid);
            const [confirmed, isVerified] = await Promise.all([
                db.getObjectField(`user:${uid}`, &#039;email:confirmed&#039;),
                groups.isMember(uid, &#039;verified-users&#039;, uid),
            ]);
            assert.strictEqual(parseInt(confirmed, 10), 1);
            assert.strictEqual(isVerified, true);
        });

        it(&#039;should remove the email from a different account if the email is already in use&#039;, async () =&gt; {
            const email = &#039;confirm2@me.com&#039;;
            const uid = await User.create({
                username: &#039;confirme3&#039;,
            });

            const oldUid = await db.sortedSetScore(&#039;email:uid&#039;, email);
            const code = await User.email.sendValidationEmail(uid, email);
            await User.email.confirmByCode(code);

            const oldUserData = await User.getUserData(oldUid);

            assert.strictEqual((await db.sortedSetScore(&#039;email:uid&#039;, email)), uid);
            assert.strictEqual(oldUserData.email, &#039;&#039;);
        });
    });

    describe(&#039;user jobs&#039;, () =&gt; {
        it(&#039;should start user jobs&#039;, (done) =&gt; {
            User.startJobs();
            done();
        });

        it(&#039;should stop user jobs&#039;, (done) =&gt; {
            User.stopJobs();
            done();
        });

        it(&#039;should send digest&#039;, (done) =&gt; {
            db.sortedSetAdd(&#039;digest:day:uids&#039;, [Date.now(), Date.now()], [1, 2], (err) =&gt; {
                assert.ifError(err);
                User.digest.execute({ interval: &#039;day&#039; }, (err) =&gt; {
                    assert.ifError(err);
                    done();
                });
            });
        });
    });

    describe(&#039;hideEmail/hideFullname&#039;, () =&gt; {
        const COMMON_PW = &#039;123456&#039;;
        const hidingUser = {
            username: &#039;hiddenemail&#039;,
            email: &#039;should@be.hidden&#039;,
            fullname: &#039;baris soner usakli&#039;,
            password: COMMON_PW,
        };
        const regularUser = {
            username: &#039;regularUser&#039;,
            email: &#039;regular@example.com&#039;,
            fullname: &#039;regular user&#039;,
            password: COMMON_PW,
        };
        let hidingUserJar;
        let adminUid;
        let adminJar;
        let globalModJar;
        let regularUserJar;

        before(async () =&gt; {
            adminUid = await User.create({
                username: &#039;adminhideemail&#039;,
                password: COMMON_PW,
            });
            await groups.join(&#039;administrators&#039;, adminUid);
            ({ jar: adminJar } = await helpers.loginUser(&#039;adminhideemail&#039;, COMMON_PW));

            // Edge case: In a grepped test, this user shouldn&#039;t be created as the first user
            // to have its email not confirmed
            hidingUser.uid = await User.create(hidingUser);
            ({ jar: hidingUserJar } = await helpers.loginUser(hidingUser.username, COMMON_PW));

            const globalModUid = await User.create({
                username: &#039;globalmodhideemail&#039;,
                password: COMMON_PW,
            });
            await groups.join(&#039;Global Moderators&#039;, globalModUid);
            ({ jar: globalModJar } = await helpers.loginUser(&#039;globalmodhideemail&#039;, COMMON_PW));

            regularUser.uid = await User.create(regularUser);
            ({ jar: regularUserJar } = await helpers.loginUser(regularUser.username, COMMON_PW));
        });

        after((done) =&gt; {
            meta.config.hideEmail = 0;
            meta.config.hideFullname = 0;
            done();
        });

        async function assertPrivacy({ expectVisible, jar, v3Api, emailOnly }) {
            const path = v3Api ? `v3/users/${hidingUser.uid}` : `user/${hidingUser.username}`;
            const response = await requestAsync(`${nconf.get(&#039;url&#039;)}/api/${path}`, { json: true, jar });
            const { response: userData } = v3Api ? response : { response };

            assert.strictEqual(userData.email, expectVisible ? hidingUser.email : &#039;&#039;);
            if (!emailOnly) {
                assert.strictEqual(userData.fullname, expectVisible ? hidingUser.fullname : &#039;&#039;);
            }
        }

        it(&#039;should hide unconfirmed emails on profile pages&#039;, async () =&gt; {
            await assertPrivacy({ v3Api: false, emailOnly: true });
            await assertPrivacy({ v3Api: false, jar: hidingUserJar, emailOnly: true });
            await assertPrivacy({ v3Api: false, jar: adminJar, emailOnly: true });
            await assertPrivacy({ v3Api: false, jar: globalModJar, emailOnly: true });
            await assertPrivacy({ v3Api: false, jar: regularUserJar, emailOnly: true });

            // Let&#039;s confirm for afterwards
            await User.email.confirmByUid(hidingUser.uid);
        });

        it(&#039;should hide from guests by default&#039;, async () =&gt; {
            await assertPrivacy({ v3Api: false });
        });

        it(&#039;should hide from unprivileged users by default&#039;, async () =&gt; {
            await assertPrivacy({ v3Api: false, jar: regularUserJar });
            await assertPrivacy({ v3Api: true, jar: regularUserJar });
        });

        it(&#039;should be visible to self by default&#039;, async () =&gt; {
            await assertPrivacy({ v3Api: false, jar: hidingUserJar, expectVisible: true });
            await assertPrivacy({ v3Api: true, jar: hidingUserJar, expectVisible: true });
        });

        it(&#039;should be visible to privileged users by default&#039;, async () =&gt; {
            await assertPrivacy({ v3Api: false, jar: adminJar, expectVisible: true });
            await assertPrivacy({ v3Api: true, jar: adminJar, expectVisible: true });
            await assertPrivacy({ v3Api: false, jar: globalModJar, expectVisible: true });
            await assertPrivacy({ v3Api: true, jar: globalModJar, expectVisible: true });
        });

        it(&#039;should hide from guests (system-wide: hide, by-user: hide)&#039;, async () =&gt; {
            meta.config.hideEmail = 1;
            meta.config.hideFullname = 1;
            // Explicitly set user&#039;s privacy settings to hide its email and fullname
            const data = { uid: hidingUser.uid, settings: { showemail: 0, showfullname: 0 } };
            await apiUser.updateSettings({ uid: hidingUser.uid }, data);

            await assertPrivacy({ v3Api: false });
        });

        it(&#039;should hide from unprivileged users (system-wide: hide, by-user: hide)&#039;, async () =&gt; {
            await assertPrivacy({ v3Api: false, jar: regularUserJar });
            await assertPrivacy({ v3Api: true, jar: regularUserJar });
        });

        it(&#039;should be visible to self (system-wide: hide, by-user: hide)&#039;, async () =&gt; {
            await assertPrivacy({ v3Api: false, jar: hidingUserJar, expectVisible: true });
            await assertPrivacy({ v3Api: true, jar: hidingUserJar, expectVisible: true });
        });

        it(&#039;should be visible to privileged users (system-wide: hide, by-user: hide)&#039;, async () =&gt; {
            await assertPrivacy({ v3Api: false, jar: adminJar, expectVisible: true });
            await assertPrivacy({ v3Api: true, jar: adminJar, expectVisible: true });
            await assertPrivacy({ v3Api: false, jar: globalModJar, expectVisible: true });
            await assertPrivacy({ v3Api: true, jar: globalModJar, expectVisible: true });
        });

        it(&#039;should hide from guests (system-wide: show, by-user: hide)&#039;, async () =&gt; {
            meta.config.hideEmail = 0;
            meta.config.hideFullname = 0;

            await assertPrivacy({ v3Api: false });
        });

        it(&#039;should hide from unprivileged users (system-wide: show, by-user: hide)&#039;, async () =&gt; {
            await assertPrivacy({ v3Api: false, jar: regularUserJar });
            await assertPrivacy({ v3Api: true, jar: regularUserJar });
        });

        it(&#039;should be visible to self (system-wide: show, by-user: hide)&#039;, async () =&gt; {
            await assertPrivacy({ v3Api: false, jar: hidingUserJar, expectVisible: true });
            await assertPrivacy({ v3Api: true, jar: hidingUserJar, expectVisible: true });
        });

        it(&#039;should be visible to privileged users (system-wide: show, by-user: hide)&#039;, async () =&gt; {
            await assertPrivacy({ v3Api: false, jar: adminJar, expectVisible: true });
            await assertPrivacy({ v3Api: true, jar: adminJar, expectVisible: true });
            await assertPrivacy({ v3Api: false, jar: globalModJar, expectVisible: true });
            await assertPrivacy({ v3Api: true, jar: globalModJar, expectVisible: true });
        });

        it(&#039;should be visible to guests (system-wide: show, by-user: show)&#039;, async () =&gt; {
            meta.config.hideEmail = 0;
            meta.config.hideFullname = 0;

            // Set user&#039;s individual privacy settings to show its email and fullname
            const data = { uid: hidingUser.uid, settings: { showemail: 1, showfullname: 1 } };
            await apiUser.updateSettings({ uid: hidingUser.uid }, data);

            await assertPrivacy({ v3Api: false, expectVisible: true });
        });

        it(&#039;should be visible to unprivileged users (system-wide: show, by-user: show)&#039;, async () =&gt; {
            await assertPrivacy({ v3Api: false, jar: regularUserJar, expectVisible: true });
            await assertPrivacy({ v3Api: true, jar: regularUserJar, expectVisible: true });
        });

        // System-wide &quot;hide&quot; prioritized over individual users&#039; settings
        it(&#039;should hide from guests (system-wide: hide, by-user: show)&#039;, async () =&gt; {
            meta.config.hideEmail = 1;
            meta.config.hideFullname = 1;

            await assertPrivacy({ v3Api: false });
        });

        it(&#039;should hide from unprivileged users (system-wide: hide, by-user: show)&#039;, async () =&gt; {
            await assertPrivacy({ v3Api: false, jar: regularUserJar });
            await assertPrivacy({ v3Api: true, jar: regularUserJar });
        });

        it(&#039;should be visible to self (system-wide: hide, by-user: show)&#039;, async () =&gt; {
            await assertPrivacy({ v3Api: false, jar: hidingUserJar, expectVisible: true });
            await assertPrivacy({ v3Api: true, jar: hidingUserJar, expectVisible: true });
        });

        it(&#039;should be visible to privileged users (system-wide: hide, by-user: show)&#039;, async () =&gt; {
            await assertPrivacy({ v3Api: false, jar: adminJar, expectVisible: true });
            await assertPrivacy({ v3Api: true, jar: adminJar, expectVisible: true });
            await assertPrivacy({ v3Api: false, jar: globalModJar, expectVisible: true });
            await assertPrivacy({ v3Api: true, jar: globalModJar, expectVisible: true });
        });

        it(&#039;should handle array of user data (system-wide: hide)&#039;, async () =&gt; {
            const userData = await User.hidePrivateData([hidingUser, regularUser], hidingUser.uid);
            assert.strictEqual(userData[0].fullname, hidingUser.fullname);
            assert.strictEqual(userData[0].email, hidingUser.email);
            assert.strictEqual(userData[1].fullname, &#039;&#039;);
            assert.strictEqual(userData[1].email, &#039;&#039;);
        });

        it(&#039;should hide fullname in topic list and topic&#039;, (done) =&gt; {
            Topics.post({
                uid: hidingUser.uid,
                title: &#039;Topic hidden&#039;,
                content: &#039;lorem ipsum&#039;,
                cid: testCid,
            }, (err) =&gt; {
                assert.ifError(err);
                request(`${nconf.get(&#039;url&#039;)}/api/recent`, { json: true }, (err, res, body) =&gt; {
                    assert.ifError(err);
                    assert(!body.topics[0].user.hasOwnProperty(&#039;fullname&#039;));
                    request(`${nconf.get(&#039;url&#039;)}/api/topic/${body.topics[0].slug}`, { json: true }, (err, res, body) =&gt; {
                        assert.ifError(err);
                        assert(!body.posts[0].user.hasOwnProperty(&#039;fullname&#039;));
                        done();
                    });
                });
            });
        });
    });

    describe(&#039;user blocking methods&#039;, (done) =&gt; {
        let blockeeUid;
        before((done) =&gt; {
            User.create({
                username: &#039;blockee&#039;,
                email: &#039;blockee@example.org&#039;,
                fullname: &#039;Block me&#039;,
            }, (err, uid) =&gt; {
                blockeeUid = uid;
                done(err);
            });
        });

        describe(&#039;.toggle()&#039;, () =&gt; {
            it(&#039;should toggle block&#039;, (done) =&gt; {
                socketUser.toggleBlock({ uid: 1 }, { blockerUid: 1, blockeeUid: blockeeUid }, (err) =&gt; {
                    assert.ifError(err);
                    User.blocks.is(blockeeUid, 1, (err, blocked) =&gt; {
                        assert.ifError(err);
                        assert(blocked);
                        done();
                    });
                });
            });

            it(&#039;should toggle block&#039;, (done) =&gt; {
                socketUser.toggleBlock({ uid: 1 }, { blockerUid: 1, blockeeUid: blockeeUid }, (err) =&gt; {
                    assert.ifError(err);
                    User.blocks.is(blockeeUid, 1, (err, blocked) =&gt; {
                        assert.ifError(err);
                        assert(!blocked);
                        done();
                    });
                });
            });
        });

        describe(&#039;.add()&#039;, () =&gt; {
            it(&#039;should block a uid&#039;, (done) =&gt; {
                User.blocks.add(blockeeUid, 1, (err) =&gt; {
                    assert.ifError(err);
                    User.blocks.list(1, (err, blocked_uids) =&gt; {
                        assert.ifError(err);
                        assert.strictEqual(Array.isArray(blocked_uids), true);
                        assert.strictEqual(blocked_uids.length, 1);
                        assert.strictEqual(blocked_uids.includes(blockeeUid), true);
                        done();
                    });
                });
            });

            it(&#039;should automatically increment corresponding user field&#039;, (done) =&gt; {
                db.getObjectField(&#039;user:1&#039;, &#039;blocksCount&#039;, (err, count) =&gt; {
                    assert.ifError(err);
                    assert.strictEqual(parseInt(count, 10), 1);
                    done();
                });
            });

            it(&#039;should error if you try to block the same uid again&#039;, (done) =&gt; {
                User.blocks.add(blockeeUid, 1, (err) =&gt; {
                    assert.equal(err.message, &#039;[[error:already-blocked]]&#039;);
                    done();
                });
            });
        });

        describe(&#039;.remove()&#039;, () =&gt; {
            it(&#039;should unblock a uid&#039;, (done) =&gt; {
                User.blocks.remove(blockeeUid, 1, (err) =&gt; {
                    assert.ifError(err);
                    User.blocks.list(1, (err, blocked_uids) =&gt; {
                        assert.ifError(err);
                        assert.strictEqual(Array.isArray(blocked_uids), true);
                        assert.strictEqual(blocked_uids.length, 0);
                        done();
                    });
                });
            });

            it(&#039;should automatically decrement corresponding user field&#039;, (done) =&gt; {
                db.getObjectField(&#039;user:1&#039;, &#039;blocksCount&#039;, (err, count) =&gt; {
                    assert.ifError(err);
                    assert.strictEqual(parseInt(count, 10), 0);
                    done();
                });
            });

            it(&#039;should error if you try to unblock the same uid again&#039;, (done) =&gt; {
                User.blocks.remove(blockeeUid, 1, (err) =&gt; {
                    assert.equal(err.message, &#039;[[error:already-unblocked]]&#039;);
                    done();
                });
            });
        });

        describe(&#039;.is()&#039;, () =&gt; {
            before((done) =&gt; {
                User.blocks.add(blockeeUid, 1, done);
            });

            it(&#039;should return a Boolean with blocked status for the queried uid&#039;, (done) =&gt; {
                User.blocks.is(blockeeUid, 1, (err, blocked) =&gt; {
                    assert.ifError(err);
                    assert.strictEqual(blocked, true);
                    done();
                });
            });
        });

        describe(&#039;.list()&#039;, () =&gt; {
            it(&#039;should return a list of blocked uids&#039;, (done) =&gt; {
                User.blocks.list(1, (err, blocked_uids) =&gt; {
                    assert.ifError(err);
                    assert.strictEqual(Array.isArray(blocked_uids), true);
                    assert.strictEqual(blocked_uids.length, 1);
                    assert.strictEqual(blocked_uids.includes(blockeeUid), true);
                    done();
                });
            });
        });

        describe(&#039;.filter()&#039;, () =&gt; {
            it(&#039;should remove entries by blocked uids and return filtered set&#039;, (done) =&gt; {
                User.blocks.filter(1, [{
                    foo: &#039;foo&#039;,
                    uid: blockeeUid,
                }, {
                    foo: &#039;bar&#039;,
                    uid: 1,
                }, {
                    foo: &#039;baz&#039;,
                    uid: blockeeUid,
                }], (err, filtered) =&gt; {
                    assert.ifError(err);
                    assert.strictEqual(Array.isArray(filtered), true);
                    assert.strictEqual(filtered.length, 1);
                    assert.equal(filtered[0].uid, 1);
                    done();
                });
            });

            it(&#039;should allow property argument to be passed in to customise checked property&#039;, (done) =&gt; {
                User.blocks.filter(1, &#039;fromuid&#039;, [{
                    foo: &#039;foo&#039;,
                    fromuid: blockeeUid,
                }, {
                    foo: &#039;bar&#039;,
                    fromuid: 1,
                }, {
                    foo: &#039;baz&#039;,
                    fromuid: blockeeUid,
                }], (err, filtered) =&gt; {
                    assert.ifError(err);
                    assert.strictEqual(Array.isArray(filtered), true);
                    assert.strictEqual(filtered.length, 1);
                    assert.equal(filtered[0].fromuid, 1);
                    done();
                });
            });

            it(&#039;should not process invalid sets&#039;, (done) =&gt; {
                User.blocks.filter(1, [{ foo: &#039;foo&#039; }, { foo: &#039;bar&#039; }, { foo: &#039;baz&#039; }], (err, filtered) =&gt; {
                    assert.ifError(err);
                    assert.strictEqual(Array.isArray(filtered), true);
                    assert.strictEqual(filtered.length, 3);
                    filtered.forEach((obj) =&gt; {
                        assert.strictEqual(obj.hasOwnProperty(&#039;foo&#039;), true);
                    });
                    done();
                });
            });

            it(&#039;should process plain sets that just contain uids&#039;, (done) =&gt; {
                User.blocks.filter(1, [1, blockeeUid], (err, filtered) =&gt; {
                    assert.ifError(err);
                    assert.strictEqual(filtered.length, 1);
                    assert.strictEqual(filtered[0], 1);
                    done();
                });
            });

            it(&#039;should filter uids that are blocking targetUid&#039;, (done) =&gt; {
                User.blocks.filterUids(blockeeUid, [1, 2], (err, filtered) =&gt; {
                    assert.ifError(err);
                    assert.deepEqual(filtered, [2]);
                    done();
                });
            });
        });
    });

    describe(&#039;status/online&#039;, () =&gt; {
        it(&#039;should return offline if user is guest&#039;, (done) =&gt; {
            const status = User.getStatus({ uid: 0 });
            assert.strictEqual(status, &#039;offline&#039;);
            done();
        });

        it(&#039;should return offline if user is guest&#039;, async () =&gt; {
            assert.strictEqual(await User.isOnline(0), false);
        });

        it(&#039;should return true&#039;, async () =&gt; {
            assert.strictEqual(await User.isOnline(testUid), true);
        });
    });

    describe(&#039;isPrivilegedOrSelf&#039;, () =&gt; {
        it(&#039;should return not error if self&#039;, (done) =&gt; {
            User.isPrivilegedOrSelf(1, 1, (err) =&gt; {
                assert.ifError(err);
                done();
            });
        });

        it(&#039;should not error if privileged&#039;, (done) =&gt; {
            User.create({ username: &#039;theadmin&#039; }, (err, uid) =&gt; {
                assert.ifError(err);
                groups.join(&#039;administrators&#039;, uid, (err) =&gt; {
                    assert.ifError(err);
                    User.isPrivilegedOrSelf(uid, 2, (err) =&gt; {
                        assert.ifError(err);
                        done();
                    });
                });
            });
        });

        it(&#039;should error if not privileged&#039;, (done) =&gt; {
            User.isPrivilegedOrSelf(0, 1, (err) =&gt; {
                assert.equal(err.message, &#039;[[error:no-privileges]]&#039;);
                done();
            });
        });
    });

    it(&#039;should get admins and mods&#039;, (done) =&gt; {
        User.getAdminsandGlobalMods((err, data) =&gt; {
            assert.ifError(err);
            assert(Array.isArray(data));
            done();
        });
    });

    it(&#039;should allow user to login even if password is weak&#039;, (done) =&gt; {
        User.create({ username: &#039;weakpwd&#039;, password: &#039;123456&#039; }, (err) =&gt; {
            assert.ifError(err);
            const oldValue = meta.config.minimumPasswordStrength;
            meta.config.minimumPasswordStrength = 3;
            helpers.loginUser(&#039;weakpwd&#039;, &#039;123456&#039;, (err) =&gt; {
                assert.ifError(err);
                meta.config.minimumPasswordStrength = oldValue;
                done();
            });
        });
    });

    describe(&#039;User\&#039;s&#039;, async () =&gt; {
        let files;

        before(async () =&gt; {
            files = await file.walk(path.resolve(__dirname, &#039;./user&#039;));
        });

        it(&#039;subfolder tests&#039;, () =&gt; {
            files.forEach((filePath) =&gt; {
                require(filePath);
            });
        });
    });
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
