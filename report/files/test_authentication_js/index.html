<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - test/authentication.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>test/authentication.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">72.86</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">639</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">62.88</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">7.41</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;


const assert = require(&#039;assert&#039;);
const url = require(&#039;url&#039;);
const async = require(&#039;async&#039;);
const nconf = require(&#039;nconf&#039;);
const request = require(&#039;request&#039;);
const util = require(&#039;util&#039;);

const db = require(&#039;./mocks/databasemock&#039;);
const user = require(&#039;../src/user&#039;);
const utils = require(&#039;../src/utils&#039;);
const meta = require(&#039;../src/meta&#039;);
const privileges = require(&#039;../src/privileges&#039;);
const helpers = require(&#039;./helpers&#039;);

describe(&#039;authentication&#039;, () =&gt; {
    const jar = request.jar();
    let regularUid;
    before((done) =&gt; {
        user.create({ username: &#039;regular&#039;, password: &#039;regularpwd&#039;, email: &#039;regular@nodebb.org&#039; }, (err, uid) =&gt; {
            assert.ifError(err);
            regularUid = uid;
            assert.strictEqual(uid, 1);
            done();
        });
    });

    it(&#039;should allow login with email for uid 1&#039;, async () =&gt; {
        const oldValue = meta.config.allowLoginWith;
        meta.config.allowLoginWith = &#039;username-email&#039;;
        const { res } = await helpers.loginUser(&#039;regular@nodebb.org&#039;, &#039;regularpwd&#039;);
        assert.strictEqual(res.statusCode, 200);
        meta.config.allowLoginWith = oldValue;
    });

    it(&#039;second user should fail to login with email since email is not confirmed&#039;, async () =&gt; {
        const oldValue = meta.config.allowLoginWith;
        meta.config.allowLoginWith = &#039;username-email&#039;;
        const uid = await user.create({ username: &#039;2nduser&#039;, password: &#039;2ndpassword&#039;, email: &#039;2nduser@nodebb.org&#039; });
        const { res, body } = await helpers.loginUser(&#039;2nduser@nodebb.org&#039;, &#039;2ndpassword&#039;);
        assert.strictEqual(res.statusCode, 403);
        assert.strictEqual(body, &#039;[[error:invalid-login-credentials]]&#039;);
        meta.config.allowLoginWith = oldValue;
    });

    it(&#039;should fail to create user if username is too short&#039;, (done) =&gt; {
        helpers.registerUser({
            username: &#039;a&#039;,
            password: &#039;123456&#039;,
        }, (err, jar, response, body) =&gt; {
            assert.ifError(err);
            assert.equal(response.statusCode, 400);
            assert.equal(body, &#039;[[error:username-too-short]]&#039;);
            done();
        });
    });

    it(&#039;should fail to create user if userslug is too short&#039;, (done) =&gt; {
        helpers.registerUser({
            username: &#039;----a-----&#039;,
            password: &#039;123456&#039;,
        }, (err, jar, response, body) =&gt; {
            assert.ifError(err);
            assert.equal(response.statusCode, 400);
            assert.equal(body, &#039;[[error:username-too-short]]&#039;);
            done();
        });
    });

    it(&#039;should fail to create user if userslug is too short&#039;, (done) =&gt; {
        helpers.registerUser({
            username: &#039;     a&#039;,
            password: &#039;123456&#039;,
        }, (err, jar, response, body) =&gt; {
            assert.ifError(err);
            assert.equal(response.statusCode, 400);
            assert.equal(body, &#039;[[error:username-too-short]]&#039;);
            done();
        });
    });

    it(&#039;should fail to create user if userslug is too short&#039;, (done) =&gt; {
        helpers.registerUser({
            username: &#039;a      &#039;,
            password: &#039;123456&#039;,
        }, (err, jar, response, body) =&gt; {
            assert.ifError(err);
            assert.equal(response.statusCode, 400);
            assert.equal(body, &#039;[[error:username-too-short]]&#039;);
            done();
        });
    });

    it(&#039;should register and login a user&#039;, (done) =&gt; {
        request({
            url: `${nconf.get(&#039;url&#039;)}/api/config`,
            json: true,
            jar: jar,
        }, (err, response, body) =&gt; {
            assert.ifError(err);

            request.post(`${nconf.get(&#039;url&#039;)}/register`, {
                form: {
                    email: &#039;admin@nodebb.org&#039;,
                    username: &#039;admin&#039;,
                    password: &#039;adminpwd&#039;,
                    &#039;password-confirm&#039;: &#039;adminpwd&#039;,
                    &#039;account-type&#039;: &#039;instructor&#039;,
                    userLang: &#039;it&#039;,
                    gdpr_consent: true,
                },
                json: true,
                jar: jar,
                headers: {
                    &#039;x-csrf-token&#039;: body.csrf_token,
                },
            }, async (err, response, body) =&gt; {
                const validationPending = await user.email.isValidationPending(body.uid, &#039;admin@nodebb.org&#039;);
                assert.strictEqual(validationPending, true);
                assert.ifError(err);
                assert(body);
                assert(body.hasOwnProperty(&#039;uid&#039;) &amp;&amp; body.uid &gt; 0);
                const newUid = body.uid;
                request({
                    url: `${nconf.get(&#039;url&#039;)}/api/self`,
                    json: true,
                    jar: jar,
                }, (err, response, body) =&gt; {
                    assert.ifError(err);
                    assert(body);
                    assert.equal(body.username, &#039;admin&#039;);
                    assert.equal(body.uid, newUid);
                    user.getSettings(body.uid, (err, settings) =&gt; {
                        assert.ifError(err);
                        assert.equal(settings.userLang, &#039;it&#039;);
                        done();
                    });
                });
            });
        });
    });

    it(&#039;should logout a user&#039;, (done) =&gt; {
        helpers.logoutUser(jar, (err) =&gt; {
            assert.ifError(err);
            request({
                url: `${nconf.get(&#039;url&#039;)}/api/me`,
                json: true,
                jar: jar,
            }, (err, res, body) =&gt; {
                assert.ifError(err);
                assert.equal(res.statusCode, 401);
                assert.strictEqual(body.status.code, &#039;not-authorised&#039;);
                done();
            });
        });
    });

    it(&#039;should login a user&#039;, (done) =&gt; {
        helpers.loginUser(&#039;regular&#039;, &#039;regularpwd&#039;, (err, data) =&gt; {
            assert.ifError(err);
            assert(data.body);
            request({
                url: `${nconf.get(&#039;url&#039;)}/api/self`,
                json: true,
                jar: data.jar,
            }, (err, response, body) =&gt; {
                assert.ifError(err);
                assert(body);
                assert.equal(body.username, &#039;regular&#039;);
                assert.equal(body.email, &#039;regular@nodebb.org&#039;);
                db.getObject(`uid:${regularUid}:sessionUUID:sessionId`, (err, sessions) =&gt; {
                    assert.ifError(err);
                    assert(sessions);
                    assert(Object.keys(sessions).length &gt; 0);
                    done();
                });
            });
        });
    });

    it(&#039;should regenerate the session identifier on successful login&#039;, async () =&gt; {
        const matchRegexp = /express\.sid=s%3A(.+?);/;
        const { hostname, path } = url.parse(nconf.get(&#039;url&#039;));

        const sid = String(jar._jar.store.idx[hostname][path][&#039;express.sid&#039;]).match(matchRegexp)[1];
        await helpers.logoutUser(jar);
        const newJar = (await helpers.loginUser(&#039;regular&#039;, &#039;regularpwd&#039;)).jar;
        const newSid = String(newJar._jar.store.idx[hostname][path][&#039;express.sid&#039;]).match(matchRegexp)[1];

        assert.notStrictEqual(newSid, sid);
    });

    it(&#039;should revoke all sessions&#039;, (done) =&gt; {
        const socketAdmin = require(&#039;../src/socket.io/admin&#039;);
        db.sortedSetCard(`uid:${regularUid}:sessions`, (err, count) =&gt; {
            assert.ifError(err);
            assert(count);
            socketAdmin.deleteAllSessions({ uid: 1 }, {}, (err) =&gt; {
                assert.ifError(err);
                db.sortedSetCard(`uid:${regularUid}:sessions`, (err, count) =&gt; {
                    assert.ifError(err);
                    assert(!count);
                    done();
                });
            });
        });
    });

    it(&#039;should fail to login if ip address is invalid&#039;, (done) =&gt; {
        const jar = request.jar();
        request({
            url: `${nconf.get(&#039;url&#039;)}/api/config`,
            json: true,
            jar: jar,
        }, (err, response, body) =&gt; {
            if (err) {
                return done(err);
            }

            request.post(`${nconf.get(&#039;url&#039;)}/login`, {
                form: {
                    username: &#039;regular&#039;,
                    password: &#039;regularpwd&#039;,
                },
                json: true,
                jar: jar,
                headers: {
                    &#039;x-csrf-token&#039;: body.csrf_token,
                    &#039;x-forwarded-for&#039;: &#039;&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;&#039;,
                },
            }, (err, response, body) =&gt; {
                assert.ifError(err);
                assert.equal(response.statusCode, 500);
                done();
            });
        });
    });

    it(&#039;should fail to login if user does not exist&#039;, (done) =&gt; {
        helpers.loginUser(&#039;doesnotexist&#039;, &#039;nopassword&#039;, (err, data) =&gt; {
            assert.ifError(err);
            assert.equal(data.res.statusCode, 403);
            assert.equal(data.body, &#039;[[error:invalid-login-credentials]]&#039;);
            done();
        });
    });

    it(&#039;should fail to login if username is empty&#039;, (done) =&gt; {
        helpers.loginUser(&#039;&#039;, &#039;some password&#039;, (err, data) =&gt; {
            assert.ifError(err);
            assert.equal(data.res.statusCode, 403);
            assert.equal(data.body, &#039;[[error:invalid-username-or-password]]&#039;);
            done();
        });
    });

    it(&#039;should fail to login if password is empty&#039;, (done) =&gt; {
        helpers.loginUser(&#039;someuser&#039;, &#039;&#039;, (err, data) =&gt; {
            assert.ifError(err);
            assert.equal(data.res.statusCode, 403);
            assert.equal(data.body, &#039;[[error:invalid-username-or-password]]&#039;);
            done();
        });
    });

    it(&#039;should fail to login if username and password are empty&#039;, (done) =&gt; {
        helpers.loginUser(&#039;&#039;, &#039;&#039;, (err, data) =&gt; {
            assert.ifError(err);
            assert.equal(data.res.statusCode, 403);
            assert.equal(data.body, &#039;[[error:invalid-username-or-password]]&#039;);
            done();
        });
    });

    it(&#039;should fail to login if user does not have password field in db&#039;, (done) =&gt; {
        user.create({ username: &#039;hasnopassword&#039;, email: &#039;no@pass.org&#039; }, (err, uid) =&gt; {
            assert.ifError(err);
            helpers.loginUser(&#039;hasnopassword&#039;, &#039;doesntmatter&#039;, (err, data) =&gt; {
                assert.ifError(err);
                assert.equal(data.res.statusCode, 403);
                assert.equal(data.body, &#039;[[error:invalid-login-credentials]]&#039;);
                done();
            });
        });
    });

    it(&#039;should fail to login if password is longer than 4096&#039;, (done) =&gt; {
        let longPassword;
        for (let i = 0; i &lt; 5000; i++) {
            longPassword += &#039;a&#039;;
        }
        helpers.loginUser(&#039;someuser&#039;, longPassword, (err, data) =&gt; {
            assert.ifError(err);
            assert.equal(data.res.statusCode, 403);
            assert.equal(data.body, &#039;[[error:password-too-long]]&#039;);
            done();
        });
    });

    it(&#039;should fail to login if local login is disabled&#039;, (done) =&gt; {
        privileges.global.rescind([&#039;groups:local:login&#039;], &#039;registered-users&#039;, (err) =&gt; {
            assert.ifError(err);
            helpers.loginUser(&#039;regular&#039;, &#039;regularpwd&#039;, (err, data) =&gt; {
                assert.ifError(err);
                assert.equal(data.res.statusCode, 403);
                assert.equal(data.body, &#039;[[error:local-login-disabled]]&#039;);
                privileges.global.give([&#039;groups:local:login&#039;], &#039;registered-users&#039;, done);
            });
        });
    });

    it(&#039;should fail to register if registraton is disabled&#039;, (done) =&gt; {
        meta.config.registrationType = &#039;disabled&#039;;
        helpers.registerUser({
            username: &#039;someuser&#039;,
            password: &#039;somepassword&#039;,
            &#039;account-type&#039;: &#039;student&#039;,
        }, (err, jar, response, body) =&gt; {
            assert.ifError(err);
            assert.equal(response.statusCode, 403);
            assert.equal(body, &#039;Forbidden&#039;);
            done();
        });
    });

    it(&#039;should return error if invitation is not valid&#039;, (done) =&gt; {
        meta.config.registrationType = &#039;invite-only&#039;;
        helpers.registerUser({
            username: &#039;someuser&#039;,
            password: &#039;somepassword&#039;,
            &#039;account-type&#039;: &#039;student&#039;,
        }, (err, jar, response, body) =&gt; {
            meta.config.registrationType = &#039;normal&#039;;
            assert.ifError(err);
            assert.equal(response.statusCode, 400);
            assert.equal(body, &#039;[[register:invite.error-invite-only]]&#039;);
            done();
        });
    });

    it(&#039;should fail to register if username is falsy or too short&#039;, (done) =&gt; {
        helpers.registerUser({
            username: &#039;&#039;,
            password: &#039;somepassword&#039;,
            &#039;account-type&#039;: &#039;student&#039;,
        }, (err, jar, response, body) =&gt; {
            assert.ifError(err);
            assert.equal(response.statusCode, 400);
            assert.equal(body, &#039;[[error:username-too-short]]&#039;);
            helpers.registerUser({
                username: &#039;a&#039;,
                password: &#039;somepassword&#039;,
                &#039;account-type&#039;: &#039;student&#039;,
            }, (err, jar, response, body) =&gt; {
                assert.ifError(err);
                assert.equal(response.statusCode, 400);
                assert.equal(body, &#039;[[error:username-too-short]]&#039;);
                done();
            });
        });
    });

    it(&#039;should fail to register if username is too long&#039;, (done) =&gt; {
        helpers.registerUser({
            username: &#039;thisisareallylongusername&#039;,
            password: &#039;123456&#039;,
            &#039;account-type&#039;: &#039;student&#039;,
        }, (err, jar, response, body) =&gt; {
            assert.ifError(err);
            assert.equal(response.statusCode, 400);
            assert.equal(body, &#039;[[error:username-too-long]]&#039;);
            done();
        });
    });

    it(&#039;should fail to register if account type is invalid&#039;, (done) =&gt; {
        helpers.registerUser({
            username: &#039;someuser&#039;,
            password: &#039;123456&#039;,
            &#039;account-type&#039;: &#039;invalidtype&#039;,
        }, (err, jar, response, body) =&gt; {
            assert.ifError(err);
            assert.equal(response.statusCode, 400);
            assert.equal(body, &#039;Invalid account type&#039;);
            done();
        });
    });

    it(&#039;should queue user if ip is used before&#039;, (done) =&gt; {
        meta.config.registrationApprovalType = &#039;admin-approval-ip&#039;;
        helpers.registerUser({
            email: &#039;another@user.com&#039;,
            username: &#039;anotheruser&#039;,
            password: &#039;anotherpwd&#039;,
            &#039;account-type&#039;: &#039;student&#039;,
            gdpr_consent: 1,
        }, (err, jar, response, body) =&gt; {
            meta.config.registrationApprovalType = &#039;normal&#039;;
            assert.ifError(err);
            assert.equal(response.statusCode, 200);
            assert.equal(body.message, &#039;[[register:registration-added-to-queue]]&#039;);
            done();
        });
    });


    it(&#039;should be able to login with email&#039;, async () =&gt; {
        const email = &#039;ginger@nodebb.org&#039;;
        const uid = await user.create({ username: &#039;ginger&#039;, password: &#039;123456&#039;, email });
        await user.setUserField(uid, &#039;email&#039;, email);
        await user.email.confirmByUid(uid);
        const { res } = await helpers.loginUser(&#039;ginger@nodebb.org&#039;, &#039;123456&#039;);
        assert.equal(res.statusCode, 200);
    });

    it(&#039;should fail to login if login type is username and an email is sent&#039;, (done) =&gt; {
        meta.config.allowLoginWith = &#039;username&#039;;
        helpers.loginUser(&#039;ginger@nodebb.org&#039;, &#039;123456&#039;, (err, data) =&gt; {
            meta.config.allowLoginWith = &#039;username-email&#039;;
            assert.ifError(err);
            assert.equal(data.res.statusCode, 400);
            assert.equal(data.body, &#039;[[error:wrong-login-type-username]]&#039;);
            done();
        });
    });

    it(&#039;should send 200 if not logged in&#039;, (done) =&gt; {
        const jar = request.jar();
        request({
            url: `${nconf.get(&#039;url&#039;)}/api/config`,
            json: true,
            jar: jar,
        }, (err, response, body) =&gt; {
            assert.ifError(err);

            request.post(`${nconf.get(&#039;url&#039;)}/logout`, {
                form: {},
                json: true,
                jar: jar,
                headers: {
                    &#039;x-csrf-token&#039;: body.csrf_token,
                },
            }, (err, res, body) =&gt; {
                assert.ifError(err);
                assert.equal(res.statusCode, 200);
                assert.equal(body, &#039;not-logged-in&#039;);
                done();
            });
        });
    });

    describe(&#039;banned user authentication&#039;, () =&gt; {
        const bannedUser = {
            username: &#039;banme&#039;,
            pw: &#039;123456&#039;,
            uid: null,
        };

        before(async () =&gt; {
            bannedUser.uid = await user.create({ username: &#039;banme&#039;, password: &#039;123456&#039;, email: &#039;ban@me.com&#039; });
        });

        it(&#039;should prevent banned user from logging in&#039;, (done) =&gt; {
            user.bans.ban(bannedUser.uid, 0, &#039;spammer&#039;, (err) =&gt; {
                assert.ifError(err);
                helpers.loginUser(bannedUser.username, bannedUser.pw, (err, data) =&gt; {
                    assert.ifError(err);
                    assert.equal(data.res.statusCode, 403);
                    delete data.body.timestamp;
                    assert.deepStrictEqual(data.body, {
                        banned_until: 0,
                        banned_until_readable: &#039;&#039;,
                        expiry: 0,
                        expiry_readable: &#039;&#039;,
                        reason: &#039;spammer&#039;,
                        uid: bannedUser.uid,
                    });
                    user.bans.unban(bannedUser.uid, (err) =&gt; {
                        assert.ifError(err);
                        const expiry = Date.now() + 10000;
                        user.bans.ban(bannedUser.uid, expiry, &#039;&#039;, (err) =&gt; {
                            assert.ifError(err);
                            helpers.loginUser(bannedUser.username, bannedUser.pw, (err, data) =&gt; {
                                assert.ifError(err);
                                assert.equal(data.res.statusCode, 403);
                                assert(data.body.banned_until);
                                assert(data.body.reason, &#039;[[user:info.banned-no-reason]]&#039;);
                                done();
                            });
                        });
                    });
                });
            });
        });

        it(&#039;should allow banned user to log in if the &quot;banned-users&quot; group has &quot;local-login&quot; privilege&#039;, async () =&gt; {
            await privileges.global.give([&#039;groups:local:login&#039;], &#039;banned-users&#039;);
            const { res } = await helpers.loginUser(bannedUser.username, bannedUser.pw);
            assert.strictEqual(res.statusCode, 200);
        });

        it(&#039;should allow banned user to log in if the user herself has &quot;local-login&quot; privilege&#039;, async () =&gt; {
            await privileges.global.rescind([&#039;groups:local:login&#039;], &#039;banned-users&#039;);
            await privileges.categories.give([&#039;local:login&#039;], 0, bannedUser.uid);
            const { res } = await helpers.loginUser(bannedUser.username, bannedUser.pw);
            assert.strictEqual(res.statusCode, 200);
        });
    });

    it(&#039;should lockout account on 3 failed login attempts&#039;, (done) =&gt; {
        meta.config.loginAttempts = 3;
        let uid;
        async.waterfall([
            function (next) {
                user.create({ username: &#039;lockme&#039;, password: &#039;123456&#039; }, next);
            },
            function (_uid, next) {
                uid = _uid;
                helpers.loginUser(&#039;lockme&#039;, &#039;abcdef&#039;, next);
            },
            function (data, next) {
                helpers.loginUser(&#039;lockme&#039;, &#039;abcdef&#039;, next);
            },
            function (data, next) {
                helpers.loginUser(&#039;lockme&#039;, &#039;abcdef&#039;, next);
            },
            function (data, next) {
                helpers.loginUser(&#039;lockme&#039;, &#039;abcdef&#039;, next);
            },
            function (data, next) {
                meta.config.loginAttempts = 5;
                assert.equal(data.res.statusCode, 403);
                assert.equal(data.body, &#039;[[error:account-locked]]&#039;);
                helpers.loginUser(&#039;lockme&#039;, &#039;abcdef&#039;, next);
            },
            function (data, next) {
                assert.equal(data.res.statusCode, 403);
                assert.equal(data.body, &#039;[[error:account-locked]]&#039;);
                db.exists(`lockout:${uid}`, next);
            },
            function (locked, next) {
                assert(locked);
                next();
            },
        ], done);
    });

    it(&#039;should clear all reset tokens upon successful login&#039;, async () =&gt; {
        const code = await user.reset.generate(regularUid);
        await helpers.loginUser(&#039;regular&#039;, &#039;regularpwd&#039;);
        const valid = await user.reset.validate(code);
        assert.strictEqual(valid, false);
    });

    describe(&#039;api tokens&#039;, () =&gt; {
        let newUid;
        let userToken;
        let masterToken;
        before(async () =&gt; {
            newUid = await user.create({ username: &#039;apiUserTarget&#039; });
            const settings = await meta.settings.get(&#039;core.api&#039;);
            settings.tokens = settings.tokens || [];
            userToken = {
                token: utils.generateUUID(),
                uid: newUid,
                description: `api token for uid ${newUid}`,
                timestamp: Date.now(),
            };
            settings.tokens.push(userToken);
            masterToken = {
                token: utils.generateUUID(),
                uid: 0,
                description: &#039;api master token&#039;,
                timestamp: Date.now(),
            };
            settings.tokens.push(masterToken);

            await meta.settings.set(&#039;core.api&#039;, settings);
        });

        it(&#039;should fail with invalid token&#039;, async () =&gt; {
            const { res, body } = await helpers.request(&#039;get&#039;, `/api/self`, {
                form: {
                    _uid: newUid,
                },
                json: true,
                jar: jar,
                headers: {
                    Authorization: `Bearer sdfhaskfdja-jahfdaksdf`,
                },
            });
            assert.strictEqual(res.statusCode, 401);
            assert.strictEqual(body, &#039;not-authorized&#039;);
        });

        it(&#039;should use a token tied to an uid&#039;, async () =&gt; {
            const { res, body } = await helpers.request(&#039;get&#039;, `/api/self`, {
                json: true,
                headers: {
                    Authorization: `Bearer ${userToken.token}`,
                },
            });

            assert.strictEqual(res.statusCode, 200);
            assert.strictEqual(body.username, &#039;apiUserTarget&#039;);
        });

        it(&#039;should fail if _uid is not passed in with master token&#039;, async () =&gt; {
            const { res, body } = await helpers.request(&#039;get&#039;, `/api/self`, {
                form: {},
                json: true,
                headers: {
                    Authorization: `Bearer ${masterToken.token}`,
                },
            });

            assert.strictEqual(res.statusCode, 500);
            assert.strictEqual(body.error, &#039;[[error:api.master-token-no-uid]]&#039;);
        });

        it(&#039;should use master api token and _uid&#039;, async () =&gt; {
            const { res, body } = await helpers.request(&#039;get&#039;, `/api/self`, {
                form: {
                    _uid: newUid,
                },
                json: true,
                headers: {
                    Authorization: `Bearer ${masterToken.token}`,
                },
            });

            assert.strictEqual(res.statusCode, 200);
            assert.strictEqual(body.username, &#039;apiUserTarget&#039;);
        });
    });
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
